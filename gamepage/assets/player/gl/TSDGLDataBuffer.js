const CHAR_MAX = 127; const UCHAR_MAX = 255; const SHRT_MAX = 32767; const USHRT_MAX = 65535; const GL_FALSE = 0; const GL_TRUE = 1; const GL_POINTS = 0; const GL_LINES = 1; const GL_LINE_LOOP = 2; const GL_LINE_STRIP = 3; const GL_TRIANGLES = 4; const GL_TRIANGLE_STRIP = 5; const GL_TRIANGLE_FAN = 6; const GL_BYTE = 5120; const GL_UNSIGNED_BYTE = 5121; const GL_SHORT = 5122; const GL_UNSIGNED_SHORT = 5123; const GL_INT = 5124; const GL_UNSIGNED_INT = 5125; const GL_FLOAT = 5126; const GL_DOUBLE = 5130; const GL_STREAM_DRAW = 35040; const GL_STATIC_DRAW = 35044; const GL_DYNAMIC_DRAW = 35048; const GL_FLOAT_VEC2 = 35664; const GL_FLOAT_VEC3 = 35665; const GL_FLOAT_VEC4 = 35666; const GL_INT_VEC2 = 35667; const GL_INT_VEC3 = 35668; const GL_INT_VEC4 = 35669; const GL_BOOL = 35670; const GL_BOOL_VEC2 = 35671; const GL_BOOL_VEC3 = 35672; const GL_BOOL_VEC4 = 35673; const GL_FLOAT_MAT2 = 35674; const GL_FLOAT_MAT3 = 35675; const GL_FLOAT_MAT4 = 35676; const GL_SAMPLER_1D = 35677; const GL_SAMPLER_2D = 35678; const GL_SAMPLER_3D = 35679; const GL_SAMPLER_CUBE = 35680; const TSDGLDataBufferDataTypeUnknown = 0; const TSDGLDataBufferDataTypeByte = GL_BYTE; const TSDGLDataBufferDataTypeUnsignedByte = GL_UNSIGNED_BYTE; const TSDGLDataBufferDataTypeShort = GL_SHORT; const TSDGLDataBufferDataTypeUnsignedShort = GL_UNSIGNED_SHORT; const TSDGLDataBufferDataTypeFloat = GL_FLOAT; function TSDGLDataBufferDataTypeAsGLEnum(b) { let a = 0; switch (b) { case TSDGLDataBufferDataTypeByte: a = GL_BYTE; break; case TSDGLDataBufferDataTypeUnsignedByte: a = GL_UNSIGNED_BYTE; break; case TSDGLDataBufferDataTypeUnsignedShort: a = GL_UNSIGNED_SHORT; break; case TSDGLDataBufferDataTypeShort: a = GL_SHORT; break; case TSDGLDataBufferDataTypeFloat: a = GL_FLOAT; break; case TSDGLDataBufferDataTypeUnknown: console.log('Unknown TSDGLdataBufferDataType!'); break; } return a; } function TSDGLDataBufferDataTypeSize(b) { let a = 0; switch (b) { case GL_BYTE: a = 1; break; case GL_UNSIGNED_BYTE: a = 1; break; case GL_SHORT: a = 2; break; case GL_UNSIGNED_SHORT: a = 2; break; case GL_FLOAT: a = 4; break; default: break; } return a; } function TSDGLPoint2DByteFromPoint2D(e, b) { const a = TSDGLbyteFromFloat(e.x, b); const d = TSDGLbyteFromFloat(e.y, b); const c = new Int8Array(2); c.set([a, d], 0); return c; } function TSDGLbyteFromFloat(b, a) { if (a) { b *= CHAR_MAX; } return b; } function TSDGLPoint2DUnsignedByteFromPoint2D(e, b) { const a = TSDGLubyteFromFloat(e.x, b); const d = TSDGLubyteFromFloat(e.y, b); const c = new Uint8Array(2); c.set([a, d], 0); return c; } function TSDGLubyteFromFloat(b, a) { if (a) { b *= UCHAR_MAX; } return b; } function TSDGLPoint2DShortFromPoint2D(e, b) { const a = TSDGLshortFromFloat(e.x, b); const d = TSDGLshortFromFloat(e.y, b); const c = new Int16Array(4); c.set([a, d], 0); return c; } function TSDGLshortFromFloat(b, a) { if (a) { b *= SHRT_MAX; } return b; } function TSDGLPoint2DUnsignedShortFromPoint2D(e, b) { const a = TSDGLushortFromFloat(e.x, b); const d = TSDGLushortFromFloat(e.y, b); const c = new Uint16Array(4); c.set([a, d], 0); return c; } function TSDGLushortFromFloat(b, a) { if (a) { b *= USHRT_MAX; } return b; } function TSDGLDataBufferSetGLPoint2DWithDataType(d, g, a, c, b) { switch (a) { case TSDGLDataBufferDataTypeByte: var e = TSDGLPoint2DByteFromPoint2D(b, c); var f = new Int8Array(d); f.set(e, g); break; case TSDGLDataBufferDataTypeUnsignedByte: var e = TSDGLPoint2DUnsignedByteFromPoint2D(b, c); var f = new Uint8Array(d); f.set(e, g); break; case TSDGLDataBufferDataTypeShort: var e = TSDGLPoint2DShortFromPoint2D(b, c); var f = new Int16Array(d); f.set(e, g / 2); break; case TSDGLDataBufferDataTypeUnsignedShort: var e = TSDGLPoint2DUnsignedShortFromPoint2D(b, c); var f = new Uint16Array(d); f.set(e, g / 2); break; case TSDGLDataBufferDataTypeFloat: var f = new Float32Array(d); f.set([b.x, b.y], g / 4); break; case TSDGLDataBufferDataTypeUnknown: console.log('Unknown data type!'); break; } } const TSDGLDataBufferAttribute = Class.create({ initialize(c, d, a, e, b) { this.locationInShader = -1; this.bufferOffset = null; this.dataArrayBuffer = null; this.dataBuffer = null; this.initWithName(c, d, a, e, b); }, initWithName(c, d, a, e, b) { this.name = c; this.bufferUsage = d; this.dataType = a; if (this.dataType === GL_SHORT) { this.dataType = GL_FLOAT; } this.componentCount = b; this.isNormalized = e; this.locationInShader = -1; } }); const TSDGLDataArrayBuffer = Class.create({
  initialize(a) { this.gl = a; this._vertexAttributes = null; this.mVertexCount = 0; this._dataTypeSizeInBytes = 0; this._bufferUsage = 0; this.mNeedsUpdateFirstIndex = []; this.mNeedsUpdateLastIndex = []; this.mGLData = null; this.mGLDataBufferHasBeenSetup = false; this.mGLDataBuffers = []; this.mAttributeOffsetsDictionary = null; this.GLDataBufferEntrySize = 0; this.bufferCount = 1; this.currentBufferIndex = 0; }, initWithVertexAttributes(g, a, f) { this._vertexAttributes = g.slice(); this.mVertexCount = a; this.mAttributeOffsetsDictionary = {}; let b = 0; let e = 0; for (var h = 0, c = this._vertexAttributes.length; h < c; h++) { const d = this._vertexAttributes[h]; d.dataArrayBuffer = this; const k = TSDGLDataBufferDataTypeSize(d.dataType); if (this._bufferUsage === 0) { this._bufferUsage = d.bufferUsage; }d.bufferOffset = e; let j = d.componentCount * k; j = (j + 3) & ~3; e += j; b += d.componentCount * 4; } this.GLDataBufferEntrySize = e; if (this.GLDataBufferEntrySize > 0) { this.mGLData = new ArrayBuffer(this.mVertexCount * this.GLDataBufferEntrySize); } this.bufferCount = f; this.mNeedsUpdateFirstIndex = []; this.mNeedsUpdateLastIndex = []; for (var h = 0; h < f; h++) { this.mNeedsUpdateFirstIndex[h] = -1; this.mNeedsUpdateLastIndex[h] = -1; } }, p_setupGLDataBufferIfNecessary() { const b = this.gl; if (this.mGLDataBufferHasBeenSetup) { return; } for (let a = 0; a < this.bufferCount; a++) { this.mGLDataBuffers[a] = b.createBuffer(); b.bindBuffer(b.ARRAY_BUFFER, this.mGLDataBuffers[a]); b.bufferData(b.ARRAY_BUFFER, this.mGLData, this._bufferUsage); this.mNeedsUpdateFirstIndex[a] = -1; this.mNeedsUpdateLastIndex[a] = -1; } this.mGLDataBufferHasBeenSetup = true; }, updateDataBufferIfNecessary() { this.p_setupGLDataBufferIfNecessary(); if (!this.hasUpdatedData()) { return; } if (this._bufferUsage == GL_STATIC_DRAW) { console.log("We're GL_STATIC_DRAW but trying (and FAILING) to update the array after initial setup!"); return; } const g = this.gl; let b = Number.MAX_SAFE_INTEGER; let h = -1; for (let d = 0; d < this.bufferCount; d++) { const e = this.mNeedsUpdateFirstIndex[d]; if (e !== -1) { b = Math.min(b, e); } const a = this.mNeedsUpdateLastIndex[d]; if (a !== -1) { h = Math.max(h, this.mNeedsUpdateLastIndex[d]); } } let f = b; let c = h + 1 - b; f *= this.GLDataBufferEntrySize; c *= this.GLDataBufferEntrySize; g.bindBuffer(g.ARRAY_BUFFER, this.mGLDataBuffers[this.currentBufferIndex]); g.bufferSubData(g.ARRAY_BUFFER, f, this.mGLData); this.mNeedsUpdateFirstIndex[this.currentBufferIndex] = -1; this.mNeedsUpdateLastIndex[this.currentBufferIndex] = -1; }, p_bufferOffsetOfAttribute(c, b, a) { let d = b * this.GLDataBufferEntrySize; d += c.bufferOffset; if (a !== 0) { d += TSDGLDataBufferDataTypeSize(c.dataType) * a; } return d; }, setGLPoint2D(b, c, a) { const d = this.p_bufferOffsetOfAttribute(c, a, 0); TSDGLDataBufferSetGLPoint2DWithDataType(this.mGLData, d, c.dataType, c.isNormalized, b); this.addIndexNeedsUpdate(a); }, enableVertexAttributeArrayBuffersWithShader(f) { const h = this.gl; this.updateDataBufferIfNecessary(); h.bindBuffer(h.ARRAY_BUFFER, this.mGLDataBuffers[this.currentBufferIndex]); for (let c = 0, e = this._vertexAttributes.length; c < e; c++) { const d = this._vertexAttributes[c]; let a = d.locationInShader; if (a === -1) { a = f.locationForAttribute(d.name); if (a === -1) { console.log(`Could not find attribute ${d.name}in shader!`); }d.locationInShader = a; } let g = 0; if (this._vertexAttributes.length > 1) { g = this.GLDataBufferEntrySize; } const b = TSDGLDataBufferDataTypeAsGLEnum(d.dataType); h.enableVertexAttribArray(a); h.vertexAttribPointer(a, d.componentCount, b, d.isNormalized ? GL_TRUE : GL_FALSE, g, d.bufferOffset); } }, disableVertexAttributeArrayBuffersWithShader(d) { const e = this.gl; for (let a = 0, c = this._vertexAttributes.length; a < c; a++) { const b = this._vertexAttributes[a]; e.disableVertexAttribArray(b.locationInShader); }e.bindBuffer(e.ARRAY_BUFFER, null); }, hasUpdatedData() { for (let a = 0; a < this.bufferCount; a++) { if (this.mNeedsUpdateFirstIndex[a] !== -1) { return true; } } return false; }, addIndexNeedsUpdate(b) { const c = this.currentBufferIndex; const d = this.mNeedsUpdateFirstIndex; const a = this.mNeedsUpdateLastIndex; d[c] = (d[c] == -1) ? b : Math.min(d[c], b); a[c] = (a[c] == -1) ? b : Math.max(a[c], b); },
}); const TSDGLDataBuffer = Class.create({
  initialize(a) { this.gl = a; this.mCurrentBufferIndex = 0; this.mArrayBuffers = []; this.mAttributeToArrayBuffersDictionary = {}; this.mElementArrayCount = 0; this.mGLElementData = null; this.mGLElementDataBufferWasSetup = false; this.mGLElementDataBuffer = null; this.mGLElementMeshSize = { width: 0, height: 0 }; this.mGLElementQuadParticleCount = 0; }, p_setupGLElementArrayBufferIfNecessary() { const e = this.gl; if (this.mGLElementDataBufferWasSetup) { return; } if (!this.mGLElementData) { this.mGLElementDataBufferWasSetup = true; return; } let b = false; let d = 0; if (!CGSizeEqualToSize(this.mGLElementMeshSize, CGSizeZero)) { b = true; for (let f = 0; f < this.mGLElementMeshSize.height - 1; ++f) { for (let a = 0; a < this.mGLElementMeshSize.width; ++a) { this.setGLushort((f + 0) * this.mGLElementMeshSize.width + a, d++); this.setGLushort((f + 1) * this.mGLElementMeshSize.width + a, d++); } } } else if (this.mGLElementQuadParticleCount != 0) { b = true; this.drawMode = GL_TRIANGLES; for (let c = 0; c < this.mGLElementQuadParticleCount; ++c) { this.setGLushort((4 * c + 0), d++); this.setGLushort((4 * c + 1), d++); this.setGLushort((4 * c + 2), d++); this.setGLushort((4 * c + 0), d++); this.setGLushort((4 * c + 2), d++); this.setGLushort((4 * c + 3), d++); } } this.mGLElementDataBuffer = e.createBuffer(); e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.mGLElementDataBuffer); this.mGLElementDataBufferWasSetup = true; }, initWithVertexAttributes(a, c) { const b = c.width * c.height; const d = c.width * 2 * (c.height - 1); this.initWithVertexAttributesDesignated(a, b, d, false); this.mGLElementMeshSize = c; }, initWithVertexAttributesDesignated(f, a, l, j) { this._doubleBuffered = j; this.drawMode = GL_TRIANGLE_STRIP; this._vertexAttributes = f; this._vertexCount = a; this.mArrayBuffers = []; this.mAttributeToArrayBuffersDictionary = {}; const n = f.slice(); while (n.length > 0) { const d = n[0]; const m = []; for (var h = 0, c = n.length; h < c; h++) { var b = n[h]; if (b.bufferUsage == d.bufferUsage) { m.push(b); } } const e = ((j && d.bufferUsage !== GL_STATIC_DRAW) ? 2 : 1); const k = new TSDGLDataArrayBuffer(this.gl); k.initWithVertexAttributes(m, a, e); for (var h = 0, c = m.length; h < c; h++) { var b = m[h]; b.dataBuffer = this; this.mAttributeToArrayBuffersDictionary[b.name] = k; } this.mArrayBuffers.push(k); for (var h = 0, c = m.length; h < c; h++) { const g = m[h]; n.splice(n.indexOf(g), 1); } } if (l > 0) { this.mElementArrayCount = l; this.mGLElementData = new ArrayBuffer(this.mElementArrayCount * 2); } }, initWithVertexRect(u, p, k, m, s) { const q = this.gl; const j = !CGRectEqualToRect(p, CGRectZero); const f = []; const l = new TSDGLDataBufferAttribute('Position', GL_STATIC_DRAW, GL_FLOAT, false, 2); f.push(l); let e; if (j) { let o = GL_SHORT; if (CGRectEqualToRect(p, CGRectMake(0, 0, 1, 1)) && CGSizeEqualToSize(k, CGSizeMake(2, 2))) { o = GL_UNSIGNED_BYTE; }e = new TSDGLDataBufferAttribute('TexCoord', GL_STATIC_DRAW, o, true, 2); f.push(e); } let c; if (s) { c = new TSDGLDataBufferAttribute('Center', GL_STATIC_DRAW, GL_FLOAT, false, 2); f.push(c); } this.initWithVertexAttributes(f, k); let h = 0; const t = TSDCenterOfRect(u); const i = parseInt(k.width - 1); const a = parseInt(k.height - 1); for (let g = 0; g <= a; ++g) { for (let d = 0; d <= i; ++d) { const n = WebGraphics.makePoint(d / i, g / a); const r = TSDPointFromNormalizedRect(n, u); this.setGLPoint2D(r, l, h); if (j) { let b = TSDPointFromNormalizedRect(n, p); if (m) { b = WebGraphics.makePoint(b.x, 1 - b.y); } this.setGLPoint2D(b, e, h); } if (s) { this.setGLPoint2D(t, c, h); }h++; } } }, setGLPoint2D(b, c, a) { c.dataArrayBuffer.setGLPoint2D(b, c, a); }, setGLushort(a, b) { const d = b; const c = new Uint16Array(this.mGLElementData); c.set([a], d); }, enableElementArrayBuffer() { const a = this.gl; this.p_setupGLElementArrayBufferIfNecessary(); if (this.mGLElementDataBufferWasSetup) { a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.mGLElementDataBuffer); } }, disableElementArrayBuffer() { const a = this.gl; if (this.mGLElementDataBufferWasSetup) { a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, null); } }, enableDataBufferWithShader(d) { if (!d.isActive) { d.activate(); } for (let b = 0, c = this.mArrayBuffers.length; b < c; b++) { const a = this.mArrayBuffers[b]; a.enableVertexAttributeArrayBuffersWithShader(d); } this.enableElementArrayBuffer(); this._enabledShader = d; this._isEnabled = true; }, disableDataBufferWithShader(d) { if (!this._isEnabled) { return; } this.disableElementArrayBuffer(); for (let b = 0, c = this.mArrayBuffers.length; b < c; b++) { const a = this.mArrayBuffers[b]; a.disableVertexAttributeArrayBuffersWithShader(d); } this._enabledShader = null; this._isEnabled = false; }, drawWithShader(h, b) { const f = this.gl; const g = { location: 0, length: this.mElementArrayCount > 0 ? this.mElementArrayCount : this._vertexCount }; this.enableDataBufferWithShader(h); if (this.mGLElementDataBufferWasSetup && this.mElementArrayCount > 0) { f.bufferData(f.ELEMENT_ARRAY_BUFFER, this.mGLElementData, f.STATIC_DRAW); if (!CGSizeEqualToSize(this.mGLElementMeshSize, CGSizeZero)) { const a = this.mGLElementMeshSize.width; for (let j = 0; j < this.mGLElementMeshSize.height - 1; ++j) { f.drawElements(this.drawMode, a * 2, f.UNSIGNED_SHORT, 2 * j * a * 2); } } else { f.drawElements(this.drawMode, g.length, f.UNSIGNED_SHORT, 2 * g.location); } } else { f.drawArrays(this.drawMode, g.location, g.length); } this.disableDataBufferWithShader(h); if (this.isDoubleBuffered) { this.mCurrentBufferIndex = (this.mCurrentBufferIndex + 1) % 2; for (let e = 0, c = this.mArrayBuffers.length; e < c; e++) { const d = this.mArrayBuffers[e]; if (d.bufferCount != 1) { d.currentBufferIndex = this.mCurrentBufferIndex; } } } if (b) { h.deactivate(); } },
});
