const kShaderUniformGravity = 'Gravity'; const kShaderUniformMaskTexture = 'MaskTexture'; const kShaderUniformNoiseAmount = 'NoiseAmount'; const kShaderUniformNoiseMax = 'NoiseMax'; const kShaderUniformNoiseSeed = 'NoiseSeed'; const kShaderUniformParticleBurstTiming = 'ParticleBurstTiming'; const kShaderUniformPreviousParticleBurstTiming = 'PreviousParticleBurstTiming'; const kShaderUniformPreviousPercent = 'PreviousPercent'; const kShaderUniformShouldSparkle = 'ShouldSparkle'; const kShaderUniformSparklePeriod = 'SparklePeriod'; const kShaderUniformSparkleStartTime = 'SparkleStartTime'; const kShaderUniformStartScale = 'StartScale'; const KNWebGLRenderer = Class.create({
  initialize(c) { const a = this.canvas = c.canvas; this.canvasId = c.canvasId; this.textureAssets = c.textureAssets; this.durationMax = c.overallEndTime * 1000; this.glPrograms = []; this.elapsed = 0; const b = this.gl = a.getContext('webgl') || a.getContext('experimental-webgl'); if (!b) { this.noGL = true; return; } this.animationStarted = false; b.viewportWidth = a.width; b.viewportHeight = a.height; this.initMVPMatrix(); }, initMVPMatrix() { const i = this.gl; const a = i.viewportWidth; const e = i.viewportHeight; const c = 20 * (Math.PI / 180); const b = e / (2 * Math.tan(c / 2)); const d = b - (a * 1.5); const f = b + (a * 15); this.slideProjectionMatrix = WebGraphics.makePerspectiveMatrix4(20, a / e, Math.max(1, d), f); const g = WebGraphics.translateMatrix4(WebGraphics.createMatrix4(), -a / 2, -e / 2, -b); this.slideProjectionMatrix = WebGraphics.multiplyMatrix4(this.slideProjectionMatrix, g); this.slideOrthoMatrix = WebGraphics.makeOrthoMatrix4(0, a, 0, e, -1, 1); }, setupTexture(c) { const a = []; this.textureInfoFromEffect(c.kpfLayer, { pointX: 0, pointY: 0 }, a); for (let b = 0, d = a.length; b < d; b++) { const f = a[b].textureId; const e = this.textureAssets[f]; a[b].texture = KNWebGLUtil.createTexture(this.gl, e); } return a; }, textureInfoFromEffect(f, e, a) { const d = {}; d.offset = { pointX: e.pointX + f.bounds.offset.pointX, pointY: e.pointY + f.bounds.offset.pointY }; if (f.textureId) { d.textureId = f.textureId; d.width = f.bounds.width; d.height = f.bounds.height; d.initialState = f.initialState; d.animations = f.animations; d.hasHighlightedBulletAnimation = f.hasHighlightedBulletAnimation; d.textureRect = { origin: { x: d.offset.pointX, y: d.offset.pointY }, size: { width: d.width, height: d.height } }; a.push(d); } else { for (let b = 0, c = f.layers.length; b < c; b++) { this.textureInfoFromEffect(f.layers[b], d.offset, a); } } }, draw(c) { const d = { effect: c, textures: this.setupTexture(c) }; const b = c.type; let a; if (b === 'transition') { switch (c.name) { case 'apple:wipe-iris': a = new KNWebGLTransitionIris(this, d); break; case 'com.apple.iWork.Keynote.BUKTwist': a = new KNWebGLTransitionTwist(this, d); break; case 'com.apple.iWork.Keynote.KLNColorPlanes': a = new KNWebGLTransitionColorPlanes(this, d); break; case 'com.apple.iWork.Keynote.BUKFlop': a = new KNWebGLTransitionFlop(this, d); break; case 'com.apple.iWork.Keynote.KLNConfetti': a = new KNWebGLTransitionConfetti(this, d); break; default: a = new KNWebGLDissolve(this, d); break; } } else if (b === 'buildIn' || b === 'buildOut') { switch (c.name) { case 'apple:wipe-iris': a = new KNWebGLBuildIris(this, d); break; case 'com.apple.iWork.Keynote.BUKAnvil': a = new KNWebGLBuildAnvil(this, d); break; case 'com.apple.iWork.Keynote.KLNFlame': a = new KNWebGLBuildFlame(this, d); break; case 'com.apple.iWork.Keynote.KNFireworks': a = new KNWebGLBuildFireworks(this, d); break; case 'com.apple.iWork.Keynote.KLNConfetti': a = new KNWebGLBuildConfetti(this, d); break; case 'com.apple.iWork.Keynote.KLNDiffuse': a = new KNWebGLBuildDiffuse(this, d); break; default: a = new KNWebGLDissolve(this, d); break; } } else if (b === 'smartBuild') { switch (c.name) { case 'apple:gallery-dissolve': a = new KNWebGLContents(this, d); break; default: a = new KNWebGLDissolve(this, d); break; } } this.removeProgram(c.objectID); this.glPrograms.push(a); }, animate() { const f = new Date(); let h = 0; if (this.time) { const b = f.getTime(); h = b - this.time; this.time = b; } else { h = 0; this.time = f.getTime(); } this.elapsed += h; const e = this.glPrograms; const d = e.length; if (this.elapsed <= this.durationMax) { this.animationRequest = window.requestAnimFrame(this.animate.bind(this)); } else { for (var c = 0; c < d; c++) { var a = e[c]; a.isCompleted = true; } } const g = this.gl; g.clearColor(0, 0, 0, 0); g.clear(g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT); for (var c = 0; c < d; c++) { var a = e[c]; a.drawFrame(h, this.elapsed, a.duration); } }, removeProgram(d) { const b = this.glPrograms; let a = b.length; while (a--) { const c = b[a]; if (c.effect.objectID === d) { b.splice(a, 1); } } }, resize(a) { const d = this.gl; const b = a.width; const c = a.height; if (d.viewportWidth !== b || d.viewportHeight !== c) { d.viewport(0, 0, b, c); d.viewportWidth = b; d.viewportHeight = c; } },
}); const KNWebGLProgram = Class.create({ initialize(d, a) { this.renderer = d; this.gl = d.gl; this.textures = a.textures; const c = this.effect = a.effect; const b = this.type = c.type; this.direction = c.attributes ? c.attributes.direction : null; this.duration = c.duration * 1000; this.buildOut = b === 'buildOut'; this.buildIn = b === 'buildIn'; this.program = {}; this.isCompleted = false; if (a.programNames) { this.setupProgram(a); } }, setupProgram(c) { const e = this.gl; for (let b = 0, d = c.programNames.length; b < d; b++) { const a = c.programNames[b]; this.program[a] = KNWebGLUtil.setupProgram(e, a); }e.enable(e.BLEND); e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA); } }); var KNWebGLContents = Class.create(KNWebGLProgram, {
  initialize($super, a, b) { this.programData = { name: 'contents', effect: b.effect, textures: b.textures }; $super(a, this.programData); this.percentfinished = 0; this.animationWillBeginWithContext(); }, animationWillBeginWithContext() { const e = this.renderer; const g = this.gl; const b = this.textures[0].textureRect; const a = CGRectMake(0, 0, b.size.width, b.size.height); const f = CGSizeMake(2, 2); const d = this.contentsShader = new TSDGLShader(g); d.initWithContentsShader(); d.setMat4WithTransform3D(e.slideProjectionMatrix, kTSDGLShaderUniformMVPMatrix); d.setGLint(0, kTSDGLShaderUniformTexture2); d.setGLint(1, kTSDGLShaderUniformTexture); const c = this.contentsDataBuffer = new TSDGLDataBuffer(g); c.initWithVertexRect(a, TSDRectUnit, f, false, false); }, drawFrame(f, a, d) { const c = this.renderer; const e = this.gl; let b = this.percentfinished; b += f / d; if (b >= 1) { b = 1; this.isCompleted = true; } this.percentfinished = b; this.p_drawContents(b); }, p_drawContents(c) { const f = this.gl; const a = this.textures; const e = a[0].texture; const b = a[1].texture; let d = TSUSineMap(c); if (c >= 1) { d = 1; }f.activeTexture(f.TEXTURE1); f.bindTexture(f.TEXTURE_2D, e); f.activeTexture(f.TEXTURE0); f.bindTexture(f.TEXTURE_2D, b); this.contentsShader.setGLFloat(d, 'mixFactor'); f.blendFunc(f.ONE, f.ONE_MINUS_SRC_ALPHA); this.contentsDataBuffer.drawWithShader(this.contentsShader, true); },
}); const KNWebGLDrawable = Class.create(KNWebGLProgram, {
  initialize($super, a, b) {
    this.programData = {
      name: 'WebDrawable', programNames: ['defaultTextureAndOpacity'], effect: b.effect, textures: b.textures,
    }; $super(a, this.programData); this.Opacity = 1; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const h = this.renderer; const g = this.gl; const f = this.program.defaultTextureAndOpacity; const j = f.uniforms; const a = f.attribs; const e = this.textures[0]; g.useProgram(f.shaderProgram); g.blendFunc(g.ONE, g.ONE_MINUS_SRC_ALPHA); const c = this.textureCoordinateBuffer = g.createBuffer(); const d = this.textureCoordinates = [0, 0, 0, 1, 1, 0, 1, 1]; g.bindBuffer(g.ARRAY_BUFFER, c); g.bufferData(g.ARRAY_BUFFER, new Float32Array(d), g.STATIC_DRAW); const i = this.positionBuffer = g.createBuffer(); const b = this.boxPosition = [0, 0, 0, 0, e.height, 0, e.width, 0, 0, e.width, e.height, 0]; g.bindBuffer(g.ARRAY_BUFFER, i); g.bufferData(g.ARRAY_BUFFER, new Float32Array(b), g.STATIC_DRAW); this.MVPMatrix = WebGraphics.translateMatrix4(h.slideProjectionMatrix, e.offset.pointX, g.viewportHeight - e.offset.pointY - e.height, 0); },
  drawFrame() { const e = this.renderer; const g = this.gl; const c = this.program.defaultTextureAndOpacity; const b = c.uniforms; const f = c.attribs; const a = this.textures; const d = a[0].texture; g.useProgram(c.shaderProgram); g.bindBuffer(g.ARRAY_BUFFER, this.textureCoordinateBuffer); g.vertexAttribPointer(f.TexCoord, 2, g.FLOAT, false, 0, 0); g.enableVertexAttribArray(f.TexCoord); g.bindBuffer(g.ARRAY_BUFFER, this.positionBuffer); g.vertexAttribPointer(f.Position, 3, g.FLOAT, false, 0, 0); g.enableVertexAttribArray(f.Position); g.uniformMatrix4fv(b.MVPMatrix, false, this.MVPMatrix); g.uniform1f(b.Opacity, this.Opacity); g.activeTexture(g.TEXTURE0); g.uniform1i(b.Texture, 0); g.bindTexture(g.TEXTURE_2D, d); g.drawArrays(g.TRIANGLE_STRIP, 0, 4); },
}); const KNWebGLFramebufferDrawable = Class.create(KNWebGLProgram, {
  initialize($super, d, f) {
    const e = d.gl; const a = this.frameRect = f.frameRect; const c = this.texture = this.createFramebufferTexture(e, a); this.buffer = this.createFramebuffer(e, c); const b = {
      width: a.size.width, height: a.size.height, offset: { pointX: 0, pointY: 0 }, texture: c,
    }; this.programData = {
      name: 'FramebufferDrawable', programNames: ['defaultTexture'], effect: f.effect, textures: [b],
    }; $super(d, this.programData); this.drawableFrame = f.drawableFrame; this.animationWillBeginWithContext();
  },
  createFramebufferTexture(c, b) { const a = c.createTexture(); c.bindTexture(c.TEXTURE_2D, a); c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, false); c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE); c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE); c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR); c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR); c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, b.size.width, b.size.height, 0, c.RGBA, c.UNSIGNED_BYTE, null); c.bindTexture(c.TEXTURE_2D, null); return a; },
  createFramebuffer(c, b) { const a = c.createFramebuffer(); c.bindFramebuffer(c.FRAMEBUFFER, a); c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, b, 0); return a; },
  animationWillBeginWithContext() { const h = this.renderer; const g = this.gl; const f = this.program.defaultTexture; const j = f.uniforms; const a = f.attribs; const e = this.textures[0]; g.useProgram(f.shaderProgram); g.blendFunc(g.ONE, g.ONE_MINUS_SRC_ALPHA); const c = this.textureCoordinateBuffer = g.createBuffer(); const d = this.textureCoordinates = [0, 1, 0, 0, 1, 1, 1, 0]; g.bindBuffer(g.ARRAY_BUFFER, c); g.bufferData(g.ARRAY_BUFFER, new Float32Array(d), g.STATIC_DRAW); const i = this.positionBuffer = g.createBuffer(); const b = this.boxPosition = [0, 0, 0, 0, e.height, 0, e.width, 0, 0, e.width, e.height, 0]; g.bindBuffer(g.ARRAY_BUFFER, i); g.bufferData(g.ARRAY_BUFFER, new Float32Array(b), g.STATIC_DRAW); this.MVPMatrix = WebGraphics.translateMatrix4(h.slideProjectionMatrix, e.offset.pointX, g.viewportHeight - e.offset.pointY - e.height, 0); },
  drawFrame() { const e = this.renderer; const g = this.gl; const c = this.program.defaultTexture; const b = c.uniforms; const f = c.attribs; const a = this.textures; const d = a[0].texture; g.useProgram(c.shaderProgram); g.bindBuffer(g.ARRAY_BUFFER, this.textureCoordinateBuffer); g.vertexAttribPointer(f.TexCoord, 2, g.FLOAT, false, 0, 0); g.enableVertexAttribArray(f.TexCoord); g.bindBuffer(g.ARRAY_BUFFER, this.positionBuffer); g.vertexAttribPointer(f.Position, 3, g.FLOAT, false, 0, 0); g.enableVertexAttribArray(f.Position); g.uniformMatrix4fv(b.MVPMatrix, false, this.MVPMatrix); g.activeTexture(g.TEXTURE0); g.uniform1i(b.Texture, 0); g.bindTexture(g.TEXTURE_2D, d); g.drawArrays(g.TRIANGLE_STRIP, 0, 4); },
}); var KNWebGLDissolve = Class.create(KNWebGLProgram, {
  initialize($super, a, b) {
    this.programData = {
      name: 'dissolve', programNames: ['defaultTextureAndOpacity'], effect: b.effect, textures: b.textures,
    }; $super(a, this.programData); this.percentfinished = 0; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const h = this.renderer; const g = this.gl; const f = this.program.defaultTextureAndOpacity; const j = f.uniforms; const a = f.attribs; const e = this.textures[0]; g.useProgram(f.shaderProgram); g.blendFunc(g.ONE, g.ONE_MINUS_SRC_ALPHA); const c = this.textureCoordinateBuffer = g.createBuffer(); const d = this.textureCoordinates = [0, 0, 0, 1, 1, 0, 1, 1]; g.bindBuffer(g.ARRAY_BUFFER, c); g.bufferData(g.ARRAY_BUFFER, new Float32Array(d), g.STATIC_DRAW); const i = this.positionBuffer = g.createBuffer(); const b = this.boxPosition = [0, 0, 0, 0, e.height, 0, e.width, 0, 0, e.width, e.height, 0]; g.bindBuffer(g.ARRAY_BUFFER, i); g.bufferData(g.ARRAY_BUFFER, new Float32Array(b), g.STATIC_DRAW); this.MVPMatrix = WebGraphics.translateMatrix4(h.slideProjectionMatrix, e.offset.pointX, g.viewportHeight - (e.offset.pointY + e.height), 0); this.drawFrame(0, 0, 4); },
  drawFrame(e, a, d) { let b = this.percentfinished; b += e / d; b > 1 ? b = 1 : 0; let c = TSUSineMap(b); if (b === 1) { c = 1; } if (this.buildOut) { c = 1 - c; } this.percentfinished = b; this.percentAlpha = c; this.draw(); },
  draw() { const f = this.renderer; const h = this.gl; const c = this.program.defaultTextureAndOpacity; const b = c.uniforms; const g = c.attribs; const a = this.textures; const e = a[0].texture; let d; if (a.length > 1) { d = a[1].texture; }h.useProgram(c.shaderProgram); h.blendFunc(h.ONE, h.ONE_MINUS_SRC_ALPHA); h.bindBuffer(h.ARRAY_BUFFER, this.textureCoordinateBuffer); h.vertexAttribPointer(g.TexCoord, 2, h.FLOAT, false, 0, 0); h.enableVertexAttribArray(g.TexCoord); h.bindBuffer(h.ARRAY_BUFFER, this.positionBuffer); h.vertexAttribPointer(g.Position, 3, h.FLOAT, false, 0, 0); h.enableVertexAttribArray(g.Position); h.uniformMatrix4fv(b.MVPMatrix, false, this.MVPMatrix); h.activeTexture(h.TEXTURE0); h.uniform1i(b.Texture, 0); if (d) { h.bindTexture(h.TEXTURE_2D, d); h.uniform1f(b.Opacity, 1); h.drawArrays(h.TRIANGLE_STRIP, 0, 4); }h.bindTexture(h.TEXTURE_2D, e); h.uniform1f(b.Opacity, this.percentAlpha); h.drawArrays(h.TRIANGLE_STRIP, 0, 4); },
}); var KNWebGLTransitionIris = Class.create(KNWebGLProgram, {
  initialize($super, a, c) {
    this.programData = {
      name: 'apple:wipe-iris', programNames: ['iris'], effect: c.effect, textures: c.textures,
    }; $super(a, this.programData); const b = this.direction; const e = b === KNDirection.kKNDirectionOut; const d = this.buildOut; if ((d && e) || (!d && !e)) { this.mix = 0; this.percentfinished = 1; } else { this.mix = 1; this.percentfinished = 0; } this.percentAlpha = 0; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const h = this.renderer; const g = this.gl; const f = this.program.iris; const a = f.attribs; const j = f.uniforms; const e = this.textures[0]; g.useProgram(f.shaderProgram); g.blendFunc(g.ONE, g.ONE_MINUS_SRC_ALPHA); this.scale = e.width / e.height; const c = this.textureCoordinatesBuffer = g.createBuffer(); const d = this.textureCoordinates = [0, 0, 0, 1, 1, 0, 1, 1]; g.bindBuffer(g.ARRAY_BUFFER, c); g.bufferData(g.ARRAY_BUFFER, new Float32Array(d), g.STATIC_DRAW); const i = this.positionBuffer = g.createBuffer(); const b = this.boxPosition = [0, 0, 0, 0, e.height, 0, e.width, 0, 0, e.width, e.height, 0]; g.bindBuffer(g.ARRAY_BUFFER, i); g.bufferData(g.ARRAY_BUFFER, new Float32Array(b), g.STATIC_DRAW); this.MVPMatrix = WebGraphics.translateMatrix4(h.slideProjectionMatrix, e.offset.pointX, g.viewportHeight - (e.offset.pointY + e.height), 0); this.drawFrame(0, 0, 4); },
  drawFrame(g, a, d) { const f = this.buildOut; const e = this.direction === KNDirection.kKNDirectionOut; let b = this.percentfinished; if ((f && e) || (!f && !e)) { b -= g / d; b < 0 ? b = 0 : 0; } else { b += g / d; b > 1 ? b = 1 : 0; } let c = TSUSineMap(b); if (b === 1) { c = 1; } if (f) { c = 1 - c; } this.percentAlpha = c; this.percentfinished = b; this.draw(); },
  draw() { const f = this.renderer; const e = this.gl; const d = this.program.iris; const a = d.attribs; const h = d.uniforms; const i = this.textures; const g = i[0].texture; const c = i[0]; let j; const b = this.scale; if (i.length > 1) { j = i[1].texture; }e.useProgram(d.shaderProgram); e.blendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA); e.bindBuffer(e.ARRAY_BUFFER, this.textureCoordinatesBuffer); e.vertexAttribPointer(a.TexCoord, 2, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(a.TexCoord); e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer); e.vertexAttribPointer(a.Position, 3, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(a.Position); e.uniformMatrix4fv(h.MVPMatrix, false, this.MVPMatrix); e.activeTexture(e.TEXTURE0); e.uniform1i(h.Texture, 0); e.uniform1f(h.Opacity, 1); if (j) { e.bindTexture(e.TEXTURE_2D, j); e.uniform1f(h.PercentForAlpha, 0); e.uniform1f(h.Scale, b); e.uniform1f(h.Mix, 0); e.drawArrays(e.TRIANGLE_STRIP, 0, 4); }e.bindTexture(e.TEXTURE_2D, g); e.uniform1f(h.PercentForAlpha, this.percentAlpha); e.uniform1f(h.Scale, b); e.uniform1f(h.Mix, this.mix); e.drawArrays(e.TRIANGLE_STRIP, 0, 4); },
}); var KNWebGLBuildIris = Class.create(KNWebGLProgram, {
  initialize($super, j, d) {
    const l = d.effect; this.programData = {
      name: 'apple:wipe-iris', programNames: ['iris'], effect: l, textures: d.textures,
    }; $super(j, this.programData); const k = this.direction; const a = k === KNDirection.kKNDirectionOut; const b = this.buildOut; if ((b && a) || (!b && !a)) { this.mix = 0; this.percentfinished = 1; } else { this.mix = 1; this.percentfinished = 0; } this.percentAlpha = 0; this.drawableObjects = []; for (let e = 0, c = this.textures.length; e < c; e++) { const h = d.textures[e]; const g = { effect: l, textures: [h] }; const f = new KNWebGLDrawable(j, g); this.drawableObjects.push(f); } this.parentOpacity = l.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() {
    const k = this.renderer; const o = this.gl; const d = this.program.iris; const g = d.attribs; const q = d.uniforms; o.useProgram(d.shaderProgram); o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA); const m = o.createBuffer(); const b = [0, 0, 0, 1, 1, 0, 1, 1]; o.bindBuffer(o.ARRAY_BUFFER, m); o.bufferData(o.ARRAY_BUFFER, new Float32Array(b), o.STATIC_DRAW); const l = o.viewportWidth; const a = o.viewportHeight; this.irisSystems = []; for (let p = 0, c = this.textures.length; p < c; p++) {
      const e = this.textures[p]; const j = e.width; const h = e.height; const s = e.width / e.height; const n = o.createBuffer(); const f = [0, 0, 0, 0, e.height, 0, e.width, 0, 0, e.width, e.height, 0]; o.bindBuffer(o.ARRAY_BUFFER, n); o.bufferData(o.ARRAY_BUFFER, new Float32Array(f), o.STATIC_DRAW); const r = WebGraphics.translateMatrix4(k.slideProjectionMatrix, e.offset.pointX, o.viewportHeight - (e.offset.pointY + e.height), 0); this.irisSystems[p] = {
        textureCoordinatesBuffer: m, positionBuffer: n, MVPMatrix: r, scale: s,
      };
    }
  },
  drawFrame(x, b, a) { const n = this.renderer; const q = this.gl; const t = this.buildOut; const u = this.direction === KNDirection.kKNDirectionOut; let m = this.percentfinished; if ((t && u) || (!t && !u)) { m -= x / a; if (m <= 0) { m = 0; this.isCompleted = true; } } else { m += x / a; if (m >= 1) { m = 1; this.isCompleted = true; } } let B = TSUSineMap(m); if (m === 1) { B = 1; } if (t) { B = 1 - B; } this.percentAlpha = B; this.percentfinished = m; q.blendFunc(q.ONE, q.ONE_MINUS_SRC_ALPHA); for (let r = 0, d = this.textures.length; r < d; r++) { const k = this.textures[r]; const s = k.initialState; const h = k.animations; if (k.hasHighlightedBulletAnimation) { if (!s.hidden) { var c; if (h.length > 0 && h[0].property === 'opacity') { const e = h[0].from.scalar; const g = h[0].to.scalar; const j = g - e; if (t) { c = e + j * (1 - this.percentfinished); } else { c = e + j * this.percentfinished; } } else { c = k.initialState.opacity; } this.drawableObjects[r].Opacity = this.parentOpacity * c; this.drawableObjects[r].drawFrame(); } } else if (k.animations.length > 0) { if (this.isCompleted) { if (!t) { this.drawableObjects[r].Opacity = this.parentOpacity * k.initialState.opacity; this.drawableObjects[r].drawFrame(); } continue; } const f = this.program.iris; const l = f.attribs; const w = f.uniforms; const v = this.irisSystems[r]; const A = v.scale; q.useProgram(f.shaderProgram); const o = v.textureCoordinatesBuffer; q.bindBuffer(q.ARRAY_BUFFER, o); q.vertexAttribPointer(l.TexCoord, 2, q.FLOAT, false, 0, 0); q.enableVertexAttribArray(l.TexCoord); const p = v.positionBuffer; q.bindBuffer(q.ARRAY_BUFFER, p); q.vertexAttribPointer(l.Position, 3, q.FLOAT, false, 0, 0); q.enableVertexAttribArray(l.Position); const z = v.MVPMatrix; q.uniformMatrix4fv(w.MVPMatrix, false, z); q.activeTexture(q.TEXTURE0); q.uniform1i(w.Texture, 0); q.uniform1f(w.Opacity, this.parentOpacity * k.initialState.opacity); q.bindTexture(q.TEXTURE_2D, k.texture); q.uniform1f(w.PercentForAlpha, this.percentAlpha); q.uniform1f(w.Scale, A); q.uniform1f(w.Mix, this.mix); q.drawArrays(q.TRIANGLE_STRIP, 0, 4); } else if (!k.initialState.hidden) { this.drawableObjects[r].Opacity = this.parentOpacity * k.initialState.opacity; this.drawableObjects[r].drawFrame(); } } },
}); var KNWebGLTransitionTwist = Class.create(KNWebGLProgram, {
  initialize($super, f, c) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.BUKTwist', programNames: ['twist'], effect: c.effect, textures: c.textures,
    }; $super(f, this.programData); const d = this.gl; this.direction = this.effect.attributes.direction; this.percentfinished = 0; const g = this.mNumPoints = 24; const n = d.viewportWidth / (g - 1); const m = d.viewportHeight / (g - 1); const k = 1 / (g - 1); let i; let h; const a = this.TexCoords = []; const j = this.PositionCoords = []; const l = this.NormalCoords = []; for (h = 0; h < g; h++) { for (i = 0; i < g; i++) { var e = h * g + i; j[e * 3] = i * n; j[e * 3 + 1] = h * m; j[e * 3 + 2] = 0; a.push(i * k); a.push(h * k); l.push(0); l.push(0); l.push(-1); } } var e = 0; const b = this.elementArray = []; for (h = 0; h < g - 1; h++) { for (i = 0; i < g; i++) { b[e++] = (h) * (g) + i; b[e++] = (h + 1) * (g) + i; } } this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const c = this.renderer; const e = this.gl; const b = this.program.twist; const a = b.uniforms; const d = b.attribs; e.enable(e.CULL_FACE); this.buffers = {}; this.buffers.TexCoord = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, this.buffers.TexCoord); e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.TexCoords), e.STATIC_DRAW); e.vertexAttribPointer(d.TexCoord, 2, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(d.TexCoord); this.buffers.Position = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, this.buffers.Position); e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.PositionCoords), e.DYNAMIC_DRAW); e.vertexAttribPointer(d.Position, 3, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(d.Position); this.buffers.Normal = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, this.buffers.Normal); e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.NormalCoords), e.DYNAMIC_DRAW); e.vertexAttribPointer(d.Normal, 3, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(d.Normal); this.MVPMatrix = c.slideProjectionMatrix; e.uniformMatrix4fv(a.MVPMatrix, false, this.MVPMatrix); this.AffineTransform = new Matrix3(); this.AffineTransform.affineScale(1, -1); this.AffineTransform.affineTranslate(0, 1); this.AffineIdentity = new Matrix3(); this.elementIndicesBuffer = e.createBuffer(); e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.elementIndicesBuffer); e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.elementArray), e.STATIC_DRAW); e.activeTexture(e.TEXTURE0); e.uniform1i(a.Texture, 0); this.drawFrame(0, 0, 4); },
  drawFrame(A, c, a) { const v = this.gl; const i = this.program.twist; const n = i.attribs; let s = this.percentfinished; s += A / a; s > 1 ? s = 1 : 0; this.specularcolor = TSUSineMap(s * 2) * 0.5; let j; let k; const p = v.viewportHeight / 2; const u = this.mNumPoints; const h = this.TexCoords; const e = this.PositionCoords; const b = this.NormalCoords; for (j = 0; j < u; j++) { for (k = 0; k < u; k++) { var g = j * u + k; const d = {}; d.x = h[g * 2]; d.y = h[g * 2 + 1]; const w = -Math.PI * TwistFX(this.direction === KNDirection.kKNDirectionLeftToRight ? d.x : (1 - d.x), s); const m = {}; m.y = (p - (p * (1 - d.y * 2) * Math.cos(w))); m.z = (p * (1 - d.y * 2) * Math.sin(w)); e[g * 3 + 1] = m.y; e[g * 3 + 2] = m.z; } } for (j = 0; j < u; j++) { for (k = 0; k < u; k++) { let z = new vector3(); var g = j * u + k; for (let o = 0; o < 4; o++) { let t = 0; let r = 0; let D = 0; let C = 0; switch (o) { case 0: t = 1; C = 1; break; case 1: r = 1; D = -1; break; case 2: t = -1; C = -1; break; case 3: r = -1; D = 1; default: break; } if ((k + t) < 0 || (k + D) < 0 || (j + r) < 0 || (j + C) < 0 || k + t >= u || k + D >= u || j + r >= u || j + C >= u) { continue; } const l = new vector3([e[g * 3], e[g * 3 + 1], e[g * 3 + 2]]); const B = new vector3([e[((j + r) * u + (k + t)) * 3], e[((j + r) * u + (k + t)) * 3 + 1], e[((j + r) * u + (k + t)) * 3 + 2]]); const f = new vector3([e[(((j + C) * u) + (k + D)) * 3], e[(((j + C) * u) + (k + D)) * 3 + 1], e[(((j + C) * u) + (k + D)) * 3 + 2]]); B.subtract(l); f.subtract(l); B.cross(f); z.add(B); }z.normalize(); z.scale(-1); z = z.getArray(); b[g * 3] = z[0]; b[g * 3 + 1] = z[1]; b[g * 3 + 2] = z[2]; } }v.bindBuffer(v.ARRAY_BUFFER, this.buffers.Position); v.bufferData(v.ARRAY_BUFFER, new Float32Array(e), v.DYNAMIC_DRAW); v.vertexAttribPointer(n.Position, 3, v.FLOAT, false, 0, 0); v.bindBuffer(v.ARRAY_BUFFER, this.buffers.Normal); v.bufferData(v.ARRAY_BUFFER, new Float32Array(b), v.DYNAMIC_DRAW); v.vertexAttribPointer(n.Normal, 3, v.FLOAT, false, 0, 0); this.percentfinished = s; this.draw(); },
  draw() { const g = this.renderer; const e = this.gl; const d = this.program.twist; const j = d.uniforms; const k = this.textures; const h = k[0].texture; const l = k[1].texture; const i = this.mNumPoints; let f = this.specularcolor; const a = this.AffineTransform.getColumnMajorFloat32Array(); const b = this.AffineIdentity.getColumnMajorFloat32Array(); const c = this.elementIndicesBuffer; if (!f) { f = 0; }e.uniform1f(j.SpecularColor, f); if (this.percentfinished < 0.5) { e.cullFace(e.BACK); e.bindTexture(e.TEXTURE_2D, h); e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c); e.uniformMatrix3fv(j.TextureMatrix, false, a); e.uniform1f(j.FlipNormals, 1); for (y = 0; y < i - 1; y++) { e.drawElements(e.TRIANGLE_STRIP, i * 2, e.UNSIGNED_SHORT, y * i * 2 * (2)); }e.cullFace(e.FRONT); e.bindTexture(e.TEXTURE_2D, l); e.uniformMatrix3fv(j.TextureMatrix, false, b); e.uniform1f(j.FlipNormals, -1); for (y = 0; y < i - 1; y++) { e.drawElements(e.TRIANGLE_STRIP, i * 2, e.UNSIGNED_SHORT, y * i * 2 * (2)); } } else { e.cullFace(e.FRONT); e.bindTexture(e.TEXTURE_2D, l); e.uniformMatrix3fv(j.TextureMatrix, false, b); e.uniform1f(j.FlipNormals, -1); for (y = 0; y < i - 1; y++) { e.drawElements(e.TRIANGLE_STRIP, i * 2, e.UNSIGNED_SHORT, y * i * 2 * (2)); }e.cullFace(e.BACK); e.bindTexture(e.TEXTURE_2D, h); e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c); e.uniformMatrix3fv(j.TextureMatrix, false, a); e.uniform1f(j.SpecularColor, f); e.uniform1f(j.FlipNormals, 1); for (y = 0; y < i - 1; y++) { e.drawElements(e.TRIANGLE_STRIP, i * 2, e.UNSIGNED_SHORT, y * i * 2 * (2)); } } },
}); var KNWebGLTransitionColorPlanes = Class.create(KNWebGLProgram, {
  initialize($super, a, c) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.KLNColorPlanes', programNames: ['colorPlanes'], effect: c.effect, textures: c.textures,
    }; $super(a, this.programData); let b = this.effect.attributes.direction; if (b !== KNDirection.kKNDirectionLeftToRight && b !== KNDirection.kKNDirectionRightToLeft && b !== KNDirection.kKNDirectionTopToBottom && b !== KNDirection.kKNDirectionBottomToTop) { b = KNDirection.kKNDirectionLeftToRight; } this.direction = b; this.mNumColors = 3; this.percentfinished = 0; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const f = this.renderer; const e = this.gl; const d = this.program.colorPlanes; const g = d.uniforms; const a = d.attribs; const c = this.textures[0]; e.disable(e.CULL_FACE); e.blendFunc(e.ONE, e.ONE); const i = this.buffers = {}; i.TexCoord = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, i.TexCoord); const b = this.TexCoords = [0, 0, 0, 1, 1, 0, 1, 1]; e.bufferData(e.ARRAY_BUFFER, new Float32Array(b), e.STATIC_DRAW); e.vertexAttribPointer(a.TexCoord, 2, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(a.TexCoord); i.Position = e.createBuffer(); e.bindBuffer(e.ARRAY_BUFFER, i.Position); const h = this.PositionCoords = [0, 0, 0, 0, c.height, 0, c.width, 0, 0, c.width, c.height, 0]; e.bufferData(e.ARRAY_BUFFER, new Float32Array(h), e.STATIC_DRAW); e.vertexAttribPointer(a.Position, 3, e.FLOAT, false, 0, 0); e.enableVertexAttribArray(a.Position); this.MVPMatrix = f.slideProjectionMatrix; e.uniformMatrix4fv(g.MVPMatrix, false, this.MVPMatrix); e.activeTexture(e.TEXTURE0); e.uniform1i(g.Texture, 0); this.drawFrame(0, 0, 4); },
  drawFrame(B, e, a) { const s = this.renderer; const v = this.gl; const n = this.program.colorPlanes; const z = n.uniforms; const q = n.attribs; const g = this.textures; const p = g[0]; const h = g[1]; this.percentfinished += B / a; this.percentfinished > 1 ? this.percentfinished = 1 : 0; const d = this.percentfinished; const A = this.direction; const t = 0.25; const o = 1; const w = (A == KNDirection.kKNDirectionRightToLeft || A == KNDirection.kKNDirectionBottomToTop); const b = (A == KNDirection.kKNDirectionLeftToRight || A == KNDirection.kKNDirectionRightToLeft); const c = 1 - (1 - d) * (1 - d); const m = b ? p.width : p.height; const i = TSUSineMap(d * 2); const C = i * m * t; let k = Math.sin(-c * 2 * Math.PI); k *= c * m * o; if (d < 0.5) { v.bindTexture(v.TEXTURE_2D, h.texture); v.uniform2fv(z.FlipTexCoords, new Float32Array([0, 0])); } else { v.bindTexture(v.TEXTURE_2D, p.texture); if (A == KNDirection.kKNDirectionTopToBottom || A == KNDirection.kKNDirectionBottomToTop) { v.uniform2fv(z.FlipTexCoords, new Float32Array([0, 1])); } else { v.uniform2fv(z.FlipTexCoords, new Float32Array([1, 0])); } } for (let f = 0, l = this.mNumColors; f < l; f++) { const r = f / l; const u = WebGraphics.colorWithHSBA(r, 1, 1, 1 / l); v.uniform4fv(z.ColorMask, new Float32Array([u.red, u.green, u.blue, u.alpha])); const x = (Math.PI / 180) * (180 * (TSUSineMap(d))); let j = WebGraphics.translateMatrix4(this.MVPMatrix, p.width / 2, p.height / 2, k); j = WebGraphics.rotateMatrix4AboutXYZ(j, x, (w ? -1 : 1) * (b ? 0 : 1), (w ? -1 : 1) * (b ? 1 : 0), 0); j = WebGraphics.translateMatrix4(j, -p.width / 2, -p.height / 2, C * (f - 1)); v.uniformMatrix4fv(z.MVPMatrix, false, j); v.drawArrays(v.TRIANGLE_STRIP, 0, 4); } },
}); var KNWebGLTransitionFlop = Class.create(KNWebGLProgram, {
  initialize($super, m, p) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.BUKFlop', programNames: ['flop', 'defaultTexture'], effect: p.effect, textures: p.textures,
    }; $super(m, this.programData); let q = this.effect.attributes.direction; if (q !== KNDirection.kKNDirectionLeftToRight && q !== KNDirection.kKNDirectionRightToLeft && q !== KNDirection.kKNDirectionTopToBottom && q !== KNDirection.kKNDirectionBottomToTop) { q = KNDirection.kKNDirectionLeftToRight; } this.direction = q; this.percentfinished = 0; const i = this.elementArray = []; const o = this.gl; const b = o.viewportWidth; const a = o.viewportHeight; let l = b; let j = a; if (q === KNDirection.kKNDirectionTopToBottom || q === KNDirection.kKNDirectionBottomToTop) { j *= 0.5; } else { l *= 0.5; } const n = this.mNumPoints = 8; let c = 0; for (e = 0; e < n - 1; e++) { for (f = 0; f < n; f++) { i[c++] = (e + 0) * (n) + f; i[c++] = (e + 1) * (n) + f; } } const h = l / (n - 1); const g = j / (n - 1); var d = (q == KNDirection.kKNDirectionTopToBottom) ? j : d = 0; var r = (q == KNDirection.kKNDirectionRightToLeft) ? l : r = 0; const k = this.attributeBufferData = {
      Position: [], TexCoords: [], Normal: [], ShadowPosition: [], ShadowTexCoord: [], PreviousPosition: [], PreviousTexCoords: [], PreviousNormal: [],
    }; for (var e = 0; e < n; e++) { for (var f = 0; f < n; f++) { c = e * n + f; KNWebGLUtil.setPoint3DAtIndexForAttribute(WebGraphics.makePoint3D(f * h + r, e * g, 0), c, k.Position); KNWebGLUtil.setPoint2DAtIndexForAttribute(WebGraphics.makePoint((f * h + r) / b, (e * g + d) / a), c, k.TexCoords); KNWebGLUtil.setPoint3DAtIndexForAttribute(WebGraphics.makePoint3D(0, 0, 1), c, k.Normal); } } this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const l = this.renderer; const m = this.gl; const d = this.program.flop; const g = d.attribs; const p = d.uniforms; const e = this.program.defaultTexture; const r = this.MVPMatrix = l.slideProjectionMatrix; let k = m.viewportWidth; let h = m.viewportHeight; const q = this.direction; if (q === KNDirection.kKNDirectionTopToBottom || q === KNDirection.kKNDirectionBottomToTop) { h *= 0.5; } else { k *= 0.5; } let b = [0, 0, 0, 0.5, 1, 0, 1, 0.5]; let f = [0, 0, 0, 0, h, 0, k, 0, 0, k, h, 0]; let c = [0, 0.5, 0, 1, 1, 0.5, 1, 1]; let a = [0, h, 0, 0, h * 2, 0, k, h, 0, k, h * 2, 0]; KNWebGLUtil.enableAttribs(m, d); const j = this.attributeBufferData; const o = this.buffers = {}; const n = this.Coordinates = {}; o.TexCoord = m.createBuffer(); m.bindBuffer(m.ARRAY_BUFFER, o.TexCoord); m.bufferData(m.ARRAY_BUFFER, new Float32Array(j.TexCoords), m.DYNAMIC_DRAW); m.vertexAttribPointer(g.TexCoord, 2, m.FLOAT, false, 0, 0); o.Position = m.createBuffer(); m.bindBuffer(m.ARRAY_BUFFER, o.Position); m.bufferData(m.ARRAY_BUFFER, new Float32Array(j.Position), m.DYNAMIC_DRAW); m.vertexAttribPointer(g.Position, 3, m.FLOAT, false, 0, 0); o.Normal = m.createBuffer(); m.bindBuffer(m.ARRAY_BUFFER, o.Normal); m.bufferData(m.ARRAY_BUFFER, new Float32Array(j.Normal), m.DYNAMIC_DRAW); m.vertexAttribPointer(g.Normal, 3, m.FLOAT, false, 0, 0); m.uniformMatrix4fv(p.MVPMatrix, false, r); const i = this.AffineTransform = new Matrix3(); if (q === KNDirection.kKNDirectionTopToBottom) { i.affineScale(1, -1); i.affineTranslate(0, 1); } else if (q == KNDirection.kKNDirectionBottomToTop) { i.affineScale(1, -1); i.affineTranslate(0, 1); b = [0, 0.5, 0, 1, 1, 0.5, 1, 1]; c = [0, 0, 0, 0.5, 1, 0, 1, 0.5]; f = [0, h, 0, 0, h * 2, 0, k, h, 0, k, h * 2, 0]; a = [0, 0, 0, 0, h, 0, k, 0, 0, k, h, 0]; } else if (q == KNDirection.kKNDirectionRightToLeft) { i.affineScale(-1, 1); i.affineTranslate(1, 0); b = [0, 0, 0, 1, 0.5, 0, 0.5, 1]; c = [0.5, 0, 0.5, 1, 1, 0, 1, 1]; a = [k, 0, 0, k, h, 0, k * 2, 0, 0, k * 2, h, 0]; } else if (q === KNDirection.kKNDirectionLeftToRight) { i.affineScale(-1, 1); i.affineTranslate(1, 0); f = [k, 0, 0, k, h, 0, k * 2, 0, 0, k * 2, h, 0]; b = [0.5, 0, 0.5, 1, 1, 0, 1, 1]; c = [0, 0, 0, 1, 0.5, 0, 0.5, 1]; a = [0, 0, 0, 0, h, 0, k, 0, 0, k, h, 0]; } this.AffineIdentity = new Matrix3(); this.elementIndicesBuffer = m.createBuffer(); m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, this.elementIndicesBuffer); m.bufferData(m.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.elementArray), m.STATIC_DRAW); n.DefaultTexture = b; n.DefaultTexture2 = c; n.DefaultPosition = f; n.DefaultPosition2 = a; KNWebGLUtil.enableAttribs(m, e); o.TextureCoordinates = m.createBuffer(); o.PositionCoordinates = m.createBuffer(); m.bindBuffer(m.ARRAY_BUFFER, o.TextureCoordinates); m.bindBuffer(m.ARRAY_BUFFER, o.PositionCoordinates); m.bufferData(m.ARRAY_BUFFER, new Float32Array(b), m.DYNAMIC_DRAW); m.vertexAttribPointer(e.attribs.TexCoord, 2, m.FLOAT, false, 0, 0); m.bufferData(m.ARRAY_BUFFER, new Float32Array(f), m.DYNAMIC_DRAW); m.vertexAttribPointer(e.attribs.Position, 3, m.FLOAT, false, 0, 0); m.uniform1i(e.uniforms.Texture, 0); m.uniformMatrix4fv(e.uniforms.MVPMatrix, false, r); m.useProgram(d.shaderProgram); m.activeTexture(m.TEXTURE0); m.uniform1i(d.uniforms.Texture, 0); this.drawFrame(0, 0, 4); },
  drawFrame(c, a, b) { this.percentfinished += c / b; this.percentfinished > 1 ? this.percentfinished = 1 : 0; this.updateFlopWithPercent(); this.draw(); },
  updateFlopWithPercent() { const r = this.gl; const u = this.direction; const c = r.viewportWidth; const b = r.viewportHeight; const g = this.percentfinished * Math.PI; const f = this.percentfinished * this.percentfinished * this.percentfinished * Math.PI; const m = b / 2; const o = c / 2; let a = 0; const q = this.mNumPoints; const n = this.attributeBufferData; for (let i = 0; i < q; i++) { for (let k = 0; k < q; k++) { const h = i * q + k; const e = KNWebGLUtil.getPoint2DForArrayAtIndex(n.TexCoords, h); e.x *= c; e.y *= b; if (u === KNDirection.kKNDirectionBottomToTop) { a = e.y / m; } else if (u === KNDirection.kKNDirectionTopToBottom) { a = (m * 2 - e.y) / m; } else if (u === KNDirection.kKNDirectionLeftToRight) { a = e.x / o; } else { a = (o * 2 - e.x) / o; } let s = a * g + (1 - a) * f; if (u === KNDirection.kKNDirectionLeftToRight || u === KNDirection.kKNDirectionTopToBottom) { s *= -1; } const d = Math.sin(s); const v = Math.cos(s); const j = KNWebGLUtil.getPoint3DForArrayAtIndex(n.Position, h); const l = KNWebGLUtil.getPoint3DForArrayAtIndex(n.Normal, h); if (u === KNDirection.kKNDirectionTopToBottom || u === KNDirection.kKNDirectionBottomToTop) { var p = WebGraphics.makePoint3D(j.x, m - (m - e.y) * v, (m - e.y) * d); KNWebGLUtil.setPoint3DAtIndexForAttribute(p, h, n.Position); var t = WebGraphics.makePoint3D(l.x, -d, v); KNWebGLUtil.setPoint3DAtIndexForAttribute(t, h, n.Normal); } else { var p = WebGraphics.makePoint3D(o - (o - e.x) * v, j.y, -(o - e.x) * d); KNWebGLUtil.setPoint3DAtIndexForAttribute(p, h, n.Position); var t = WebGraphics.makePoint3D(-d, l.y, v); KNWebGLUtil.setPoint3DAtIndexForAttribute(t, h, n.Normal); } } } },
  draw() { const e = this.renderer; const d = this.gl; const c = this.program.flop; const b = this.program.defaultTexture; const h = this.textures; const l = h[1].texture; const j = h[0].texture; d.useProgram(b.shaderProgram); d.disable(d.CULL_FACE); d.bindTexture(d.TEXTURE_2D, l); const f = this.mNumPoints; const k = this.buffers; const a = this.Coordinates; const i = this.attributeBufferData; KNWebGLUtil.bindDynamicBufferWithData(d, b.attribs.Position, k.PositionCoordinates, a.DefaultPosition, 3); KNWebGLUtil.bindDynamicBufferWithData(d, b.attribs.TexCoord, k.TextureCoordinates, a.DefaultTexture, 2); d.drawArrays(d.TRIANGLE_STRIP, 0, 4); d.useProgram(b.shaderProgram); d.disable(d.CULL_FACE); d.bindTexture(d.TEXTURE_2D, j); KNWebGLUtil.bindDynamicBufferWithData(d, b.attribs.Position, k.PositionCoordinates, a.DefaultPosition2, 3); KNWebGLUtil.bindDynamicBufferWithData(d, b.attribs.TexCoord, k.TextureCoordinates, a.DefaultTexture2, 2); d.drawArrays(d.TRIANGLE_STRIP, 0, 4); d.enable(d.CULL_FACE); d.useProgram(c.shaderProgram); d.bindBuffer(d.ARRAY_BUFFER, k.Position); d.bufferData(d.ARRAY_BUFFER, new Float32Array(i.Position), d.DYNAMIC_DRAW); d.vertexAttribPointer(c.attribs.Position, 3, d.FLOAT, false, 0, 0); d.bindBuffer(d.ARRAY_BUFFER, k.Normal); d.bufferData(d.ARRAY_BUFFER, new Float32Array(i.Normal), d.DYNAMIC_DRAW); d.vertexAttribPointer(c.attribs.Normal, 3, d.FLOAT, false, 0, 0); d.bindBuffer(d.ARRAY_BUFFER, k.TexCoord); d.bufferData(d.ARRAY_BUFFER, new Float32Array(i.TexCoords), d.DYNAMIC_DRAW); d.vertexAttribPointer(c.attribs.TexCoord, 2, d.FLOAT, false, 0, 0); d.cullFace(d.BACK); d.bindTexture(d.TEXTURE_2D, j); d.uniformMatrix3fv(c.uniforms.TextureMatrix, false, this.AffineTransform.getColumnMajorFloat32Array()); d.uniform1f(c.uniforms.FlipNormals, -1); for (var g = 0; g < f - 1; g++) { d.drawElements(d.TRIANGLE_STRIP, f * 2, d.UNSIGNED_SHORT, g * f * 2 * (2)); }d.bindTexture(d.TEXTURE_2D, l); d.cullFace(d.FRONT); d.uniformMatrix3fv(c.uniforms.TextureMatrix, false, this.AffineIdentity.getColumnMajorFloat32Array()); d.uniform1f(c.uniforms.FlipNormals, 1); for (var g = 0; g < f - 1; g++) { d.drawElements(d.TRIANGLE_STRIP, f * 2, d.UNSIGNED_SHORT, g * f * 2 * (2)); } },
}); var KNWebGLBuildAnvil = Class.create(KNWebGLProgram, {
  initialize($super, g, b) {
    const j = b.effect; this.programData = {
      name: 'com.apple.iWork.Keynote.BUKAnvil', programNames: ['anvilsmoke', 'anvilspeck'], effect: j, textures: b.textures,
    }; $super(g, this.programData); const d = this.gl; this.smokeTexture = KNWebGLUtil.bindTextureWithImage(d, smokeImage); this.speckTexture = KNWebGLUtil.bindTextureWithImage(d, speckImage); this.percentfinished = 0; this.drawableObjects = []; for (let c = 0, a = this.textures.length; c < a; c++) { const h = b.textures[c]; const f = { effect: j, textures: [h] }; const e = new KNWebGLDrawable(g, f); this.drawableObjects.push(e); } this.objectY = 1; this.parentOpacity = j.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const l = this.renderer; const h = this.gl; this.smokeSystems = []; this.speckSystems = []; for (let e = 0, b = this.textures.length; e < b; e++) { const d = this.textures[e]; const a = d.width; const m = d.height; const j = h.viewportWidth; const g = h.viewportHeight; let f = 300; const k = new KNWebGLBuildAnvilSmokeSystem(l, this.program.anvilsmoke, { width: a, height: m }, { width: j, height: g }, this.duration, { width: f, height: 1 }, { width: kParticleSize, height: kParticleSize }, this.smokeTexture); f = 40; const c = new KNWebGLBuildAnvilSpeckSystem(l, this.program.anvilspeck, { width: a, height: m }, { width: j, height: g }, this.duration, { width: f, height: 1 }, { width: kParticleSize, height: kParticleSize }, this.speckTexture); this.smokeSystems.push(k); this.speckSystems.push(c); } },
  drawFrame(a, h, r) { const w = this.renderer; const n = this.gl; this.percentfinished += a / r; if (this.percentfinished >= 1) { this.percentfinished = 1; this.isCompleted = true; }n.blendFunc(n.ONE, n.ONE_MINUS_SRC_ALPHA); for (let F = 0, p = this.textures.length; F < p; F++) { const e = this.textures[F]; const C = e.initialState; const K = e.animations; if (e.hasHighlightedBulletAnimation) { if (!C.hidden) { var G; if (K.length > 0 && K[0].property === 'opacity') { const L = K[0].from.scalar; const x = K[0].to.scalar; const t = x - L; G = L + t * this.percentfinished; } else { G = e.initialState.opacity; } this.drawableObjects[F].Opacity = this.parentOpacity * G; this.drawableObjects[F].drawFrame(); } } else if (e.animations.length > 0) { if (this.isCompleted) { this.drawableObjects[F].Opacity = this.parentOpacity * e.initialState.opacity; this.drawableObjects[F].drawFrame(); continue; } const b = e.width; const d = e.height; const A = e.offset.pointX; const z = e.offset.pointY; const q = n.viewportWidth; const o = n.viewportHeight; r /= 1000; const E = Math.min(0.2, r * 0.4); const s = Math.min(0.25, r * 0.5); const B = this.cameraShakePointsWithRandomGenerator(); const m = (this.percentfinished * r - E) / s; let v = WebGraphics.makePoint(0, 0); if (m > 0 && m < 1) { const I = Math.floor(m * kNumCameraShakePoints); const g = Math.ceil(WebGraphics.clamp(m * kNumCameraShakePoints, 0, B.length - 1)); const J = B[I]; const j = B[g]; const f = m * kNumCameraShakePoints - I; v = WebGraphics.makePoint(WebGraphics.mix(J.x, j.x, f), WebGraphics.mix(J.y, j.y, f)); } const u = WebGraphics.clamp((this.percentfinished * r) / E, 0, 1); const k = WebGraphics.clamp(((this.percentfinished * r) - E) / (r - E), 0, 1); const c = this.percentfinished; this.objectY = z + d; this.objectY *= (1 - u * u); this.drawableObjects[F].MVPMatrix = WebGraphics.translateMatrix4(w.slideOrthoMatrix, A + (v.x * q), o - z - d + this.objectY + (v.y * o), 0); this.drawableObjects[F].Opacity = this.parentOpacity * e.initialState.opacity; this.drawableObjects[F].drawFrame(); let D = WebGraphics.translateMatrix4(w.slideProjectionMatrix, A, o - (z + (d + 16)) * (1 - (k * k * 0.02)), 0); const l = this.smokeSystems[F]; l.setMVPMatrix(D); l.drawFrame(k, 1 - (k * k)); if (k < 0.5) { D = WebGraphics.translateMatrix4(w.slideOrthoMatrix, A, o - (z + d + 16), 0); const H = this.speckSystems[F]; H.setMVPMatrix(D); H.drawFrame(k, WebGraphics.clamp(1 - WebGraphics.sineMap(k) * 2, 0, 1)); } } else if (!e.initialState.hidden) { this.drawableObjects[F].Opacity = this.parentOpacity * e.initialState.opacity; this.drawableObjects[F].drawFrame(); } } },
  cameraShakePointsWithRandomGenerator() { const e = []; const c = 0.025; for (let a = 0; a < kNumCameraShakePoints; a++) { let d = 1 - (a / kNumCameraShakePoints); d *= d; const b = WebGraphics.makePoint(WebGraphics.randomBetween(-1, 1) * c * d * 0.4, Math.pow(-1, a) * c * d); e[a] = b; } return e; },
}); var KNWebGLBuildFlame = Class.create(KNWebGLProgram, {
  initialize($super, k, d) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.KLNFlame', programNames: ['flame'], effect: d.effect, textures: d.textures,
    }; $super(k, this.programData); const g = this.gl; this.flameTexture = KNWebGLUtil.bindTextureWithImage(g, flameImage); this.percentfinished = 0; this.drawableObjects = []; this.framebufferDrawableObjects = []; this.slideSize = { width: g.viewportWidth, height: g.viewportHeight }; const n = this.effect; for (let f = 0, c = this.textures.length; f < c; f++) {
      const l = d.textures[f]; const j = { effect: n, textures: [l] }; const h = new KNWebGLDrawable(k, j); this.drawableObjects.push(h); const m = { size: { width: l.width, height: l.height }, origin: { x: l.offset.pointX, y: l.offset.pointY } }; const a = this.frameOfEffectWithFrame(m); const e = {
        effect: n, textures: [], drawableFrame: m, frameRect: a,
      }; const b = new KNWebGLFramebufferDrawable(k, e); this.framebufferDrawableObjects.push(b);
    } this.parentOpacity = n.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  frameOfEffectWithFrame(g) { const d = g.size; const f = this.slideSize; const i = (1.2 - Math.min(1, Math.sqrt(d.width / f.width))) + 1; const e = (1.25 - Math.min(1, Math.sqrt(d.height / f.height))) + 1; const h = { width: Math.round(d.width * i), height: Math.round(d.height * e) }; if (d.width / d.height < 1) { h.width = Math.max(h.width, (d.width + d.height)); } const j = { size: h, origin: { x: g.origin.x + (d.width - h.width) / 2, y: g.origin.y + (d.height - h.height) / 2 } }; j.origin.y -= (j.size.height - g.size.height) * 0.25; const c = this.gl; const b = { origin: { x: 0, y: 0 }, size: { width: c.viewportWidth, height: c.viewportHeight } }; let a = CGRectIntersection(j, b); a = CGRectIntegral(a); return a; },
  p_orthoTransformWithScale(f, e, d) { const c = { width: d.size.width * f, height: d.size.height * f }; const b = WebGraphics.makeOrthoMatrix4(0, c.width, 0, c.height, -1, 1); const a = WebGraphics.translateMatrix4(b, e.x, -e.y, 0); return a; },
  animationWillBeginWithContext() { const j = this.renderer; const m = this.gl; const a = this.duration / 1000; this.flameSystems = []; for (let n = 0, c = this.textures.length; n < c; n++) { const f = this.textures[n]; const h = f.width; const g = f.height; const l = m.viewportWidth; const b = m.viewportHeight; const e = this.framebufferDrawableObjects[n]; const q = e.frameRect; const s = e.drawableFrame; const k = { x: f.offset.pointX - q.origin.x, y: f.offset.pointY + g - (q.origin.y + q.size.height) }; const t = s.origin.y - q.origin.y; const o = q.origin.y + q.size.height - (s.origin.y + s.size.height); k.y += (o - t); e.MVPMatrix = this.p_orthoTransformWithScale(1, k, q); const d = h / g; let p = Math.round(d * 150); p *= (a + Math.max(0, 1 - a / 2)); const r = new KNWebGLBuildFlameSystem(j, this.program.flame, { width: h, height: g }, { width: l, height: b }, Math.max(2, this.duration), p, this.flameTexture); r.p_setupParticleDataWithTexture(f); this.flameSystems.push(r); } },
  drawFrame(a, h, u) { const x = this.renderer; const m = this.gl; const c = this.program.flame; const n = c.uniforms; const g = this.buildOut; let l = this.percentfinished; l += a / u; if (l >= 1) { l = 1; this.isCompleted = true; } this.percentfinished = l; m.blendFunc(m.ONE, m.ONE_MINUS_SRC_ALPHA); for (let K = 0, p = this.textures.length; K < p; K++) { const f = this.textures[K]; const E = f.initialState; const N = f.animations; if (f.hasHighlightedBulletAnimation) { if (!E.hidden) { var L; if (N.length > 0 && N[0].property === 'opacity') { const O = N[0].from.scalar; const z = N[0].to.scalar; const v = z - O; L = O + v * this.percentfinished; } else { L = f.initialState.opacity; } this.drawableObjects[K].Opacity = this.parentOpacity * L; this.drawableObjects[K].drawFrame(); } } else if (f.animations.length > 0) { if (this.isCompleted) { if (!g) { this.drawableObjects[K].Opacity = this.parentOpacity * f.initialState.opacity; this.drawableObjects[K].drawFrame(); } continue; } const b = f.width; const e = f.height; const C = f.offset.pointX; const B = f.offset.pointY; const r = m.viewportWidth; const o = m.viewportHeight; u /= 1000; let d = l; if (g) { d = 1 - d; } const J = g ? 0.25 : 0.5; const t = Math.min(J, 1 / u); if (d > t) { const j = (d - t) / (1 - t); let H = TSUSineMap(Math.min(1, 2 * j)); H *= this.parentOpacity * f.initialState.opacity; const D = this.drawableObjects[K]; D.Opacity = H; D.drawFrame(); } const w = this.framebufferDrawableObjects[K]; const F = w.drawableFrame; const A = w.frameRect; const k = { x: f.offset.pointX - A.origin.x, y: f.offset.pointY + e - (A.origin.y + A.size.height) }; const I = F.origin.y - A.origin.y; const M = A.origin.y + A.size.height - (F.origin.y + F.size.height); k.y += (M - I); const G = this.p_orthoTransformWithScale(1, k, A); m.viewport(0, 0, A.size.width, A.size.height); m.bindFramebuffer(m.FRAMEBUFFER, w.buffer); m.clear(m.COLOR_BUFFER_BIT); m.enable(m.BLEND); m.blendFunc(m.SRC_ALPHA, m.ONE); const q = (l == 0 || l == 1 ? 0 : 1); m.bindTexture(m.TEXTURE_2D, w.texture); const s = this.flameSystems[K]; s.setMVPMatrix(G); m.uniform1f(n.SpeedMax, s._speedMax); s.drawFrame(l, q); m.bindFramebuffer(m.FRAMEBUFFER, null); m.bindTexture(m.TEXTURE_2D, null); m.viewport(0, 0, m.viewportWidth, m.viewportHeight); m.blendFunc(m.ONE, m.ONE_MINUS_SRC_ALPHA); w.MVPMatrix = WebGraphics.translateMatrix4(x.slideProjectionMatrix, A.origin.x, m.viewportHeight - (A.origin.y + A.size.height), 0); w.drawFrame(); } else if (!f.initialState.hidden) { this.drawableObjects[K].Opacity = this.parentOpacity * f.initialState.opacity; this.drawableObjects[K].drawFrame(); } } },
}); var KNWebGLTransitionConfetti = Class.create(KNWebGLProgram, {
  initialize($super, a, b) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.KLNConfetti', programNames: ['confetti', 'defaultTexture'], effect: b.effect, textures: b.textures,
    }; $super(a, this.programData); this.useGravity = this.direction === KNDirection.kKNDirectionGravity; this.percentfinished = 0; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const j = this.renderer; const g = this.gl; const k = this.textures; const d = k[0]; const b = d.width; const l = d.height; const i = g.viewportWidth; const h = g.viewportHeight; const f = 10000; g.blendFunc(g.SRC_ALPHA, g.ONE_MINUS_SRC_ALPHA); this.confettiSystem = new KNWebGLBuildConfettiSystem(j, this.program.confetti, { width: b, height: l }, { width: i, height: h }, this.duration, f, k[1].texture); this.confettiSystem.setMVPMatrix(j.slideProjectionMatrix); const e = this.program.defaultTexture; KNWebGLUtil.enableAttribs(g, e); const c = [0, 0, 0, 1, 1, 0, 1, 1]; const a = [0, 0, -1, 0, h, -1, i, 0, -1, i, h, -1]; this.textureCoordinatesBuffer = g.createBuffer(); g.bindBuffer(g.ARRAY_BUFFER, this.textureCoordinatesBuffer); g.bufferData(g.ARRAY_BUFFER, new Float32Array(c), g.STATIC_DRAW); g.vertexAttribPointer(e.attribs.TexCoord, 2, g.FLOAT, false, 0, 0); this.positionBuffer = g.createBuffer(); KNWebGLUtil.bindDynamicBufferWithData(g, e.attribs.Position, this.positionBuffer, a, 3); g.uniformMatrix4fv(e.uniforms.MVPMatrix, false, j.slideOrthoMatrix); g.activeTexture(g.TEXTURE0); g.uniform1i(e.uniforms.Texture, 0); this.drawFrame(0, 0, 4); },
  drawFrame(b, p, e) { const g = this.gl; const j = g.viewportWidth; const h = g.viewportHeight; let a = this.percentfinished; a += b / e; if (a > 1) { a = 1; this.isCompleted = true; } const l = this.percentfinished = a; const i = 1 - l; let k = 1 - i * i * i; k = k * (1 - l * l) + (1 - i * i) * (l * l) + l; k *= 0.5; k *= k; const d = 0.75 + (1 - Math.pow(i, 4)) * 0.25; let n = WebGraphics.translateMatrix4(this.renderer.slideProjectionMatrix, j / 2, h / 2, 0); n = WebGraphics.scaleMatrix4(n, d, d, 1); n = WebGraphics.translateMatrix4(n, -j / 2, -h / 2, 0); const f = this.program.defaultTexture; g.useProgram(f.shaderProgram); g.uniformMatrix4fv(f.uniforms.MVPMatrix, false, n); this.draw(); let o = 1 - l; o = WebGraphics.clamp(o, 0, 1); k = WebGraphics.clamp(k, 0, 1); if (this.useGravity) { const m = 1; let c = this.renderer.slideProjectionMatrix; c = WebGraphics.translateMatrix4(c, 0, -h * 2 * l * l * (1 - m * 0.5), 0); this.confettiSystem.setMVPMatrix(c); } this.confettiSystem.drawFrame(k, o); },
  draw() { const g = this.gl; const d = this.program.defaultTexture; const f = d.attribs; const b = g.viewportWidth; const c = g.viewportHeight; g.useProgram(d.shaderProgram); const a = [0, 0, 0, 1, 1, 0, 1, 1]; const e = [0, 0, -1, 0, c, -1, b, 0, -1, b, c, -1]; g.bindBuffer(g.ARRAY_BUFFER, this.textureCoordinatesBuffer); g.bufferData(g.ARRAY_BUFFER, new Float32Array(a), g.STATIC_DRAW); g.vertexAttribPointer(f.TexCoord, 2, g.FLOAT, false, 0, 0); KNWebGLUtil.bindDynamicBufferWithData(g, f.Position, this.positionBuffer, e, 3); g.bindTexture(g.TEXTURE_2D, this.textures[0].texture); g.drawArrays(g.TRIANGLE_STRIP, 0, 4); },
}); var KNWebGLBuildConfetti = Class.create(KNWebGLProgram, {
  initialize($super, f, b) {
    const h = b.effect; this.programData = {
      name: 'com.apple.iWork.Keynote.KLNConfetti', programNames: ['confetti'], effect: h, textures: b.textures,
    }; $super(f, this.programData); this.useGravity = this.direction === KNDirection.kKNDirectionGravity; this.percentfinished = 0; this.drawableObjects = []; for (let c = 0, a = this.textures.length; c < a; c++) { const g = b.textures[c]; const e = { effect: h, textures: [g] }; const d = new KNWebGLDrawable(f, e); this.drawableObjects.push(d); } this.parentOpacity = h.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const l = this.renderer; const g = this.gl; const j = g.viewportWidth; const h = g.viewportHeight; this.confettiSystems = []; for (let e = 0, b = this.textures.length; e < b; e++) { const d = this.textures[e]; const a = d.width; const m = d.height; let k = (m / h * a / j); k = Math.sqrt(Math.sqrt(k)); const f = Math.round(k * 10000); const c = new KNWebGLBuildConfettiSystem(l, this.program.confetti, { width: a, height: m }, { width: j, height: h }, this.duration, f, d.texture); c.ratio = k; this.confettiSystems.push(c); } },
  drawFrame(C, c, a) { const v = this.renderer; const x = this.gl; const w = x.viewportWidth; const d = x.viewportHeight; const g = this.buildIn; const B = this.buildOut; let t = this.percentfinished; t += C / a; if (t > 1) { t = 1; this.isCompleted = true; } this.percentfinished = t; for (let z = 0, f = this.textures.length; z < f; z++) { const r = this.textures[z]; const A = r.initialState; const n = r.animations; if (r.hasHighlightedBulletAnimation) { if (!A.hidden) { var e; if (n.length > 0 && n[0].property === 'opacity') { const k = n[0].from.scalar; const m = n[0].to.scalar; const q = m - k; e = k + q * t; } else { e = r.initialState.opacity; }x.blendFunc(x.ONE, x.ONE_MINUS_SRC_ALPHA); this.drawableObjects[z].Opacity = this.parentOpacity * e; this.drawableObjects[z].drawFrame(); } } else if (r.animations.length > 0) { if (this.isCompleted) { if (g) { this.drawableObjects[z].Opacity = this.parentOpacity * r.initialState.opacity; this.drawableObjects[z].drawFrame(); } continue; } const u = r.width; const s = r.height; const b = g ? 1 - t : t; const j = 1 - b; let p = 1 - j * j * j; p = p * (1 - b * b) + (1 - j * j) * (b * b) + b; p *= 0.5; if (g) { p *= p; } const h = this.confettiSystems[z]; let D = WebGraphics.translateMatrix4(v.slideProjectionMatrix, r.offset.pointX, d - (r.offset.pointY + s), 0); let o = 1 - b; o = WebGraphics.clamp(o, 0, 1); p = WebGraphics.clamp(p, 0, 1); if (this.useGravity) { const l = h.ratio; D = WebGraphics.translateMatrix4(D, 0, -d * 2 * b * b * (1 - l * 0.5), 0); }x.blendFunc(x.SRC_ALPHA, x.ONE_MINUS_SRC_ALPHA); h.setMVPMatrix(D); h.drawFrame(p, o); } else if (!r.initialState.hidden) { x.blendFunc(x.ONE, x.ONE_MINUS_SRC_ALPHA); this.drawableObjects[z].Opacity = this.parentOpacity * r.initialState.opacity; this.drawableObjects[z].drawFrame(); } } },
}); var KNWebGLBuildDiffuse = Class.create(KNWebGLProgram, {
  initialize($super, f, b) {
    const h = b.effect; this.programData = {
      name: 'com.apple.iWork.Keynote.KLNDiffuse', programNames: ['diffuse'], effect: h, textures: b.textures,
    }; $super(f, this.programData); this.percentfinished = 0; this.drawableObjects = []; for (let c = 0, a = this.textures.length; c < a; c++) { const g = b.textures[c]; const e = { effect: h, textures: [g] }; const d = new KNWebGLDrawable(f, e); this.drawableObjects.push(d); } this.parentOpacity = h.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  animationWillBeginWithContext() { const l = this.renderer; const g = this.gl; const j = g.viewportWidth; const h = g.viewportHeight; this.diffuseSystems = []; for (let e = 0, b = this.textures.length; e < b; e++) { const d = this.textures[e]; const a = d.width; const m = d.height; let k = (m / h * a / j); k = Math.sqrt(Math.sqrt(k)); const f = Math.round(k * 4000); const c = new KNWebGLBuildDiffuseSystem(l, this.program.diffuse, { width: a, height: m }, { width: j, height: h }, this.duration, f, d.texture, this.direction === KNDirection.kKNDirectionRightToLeft); this.diffuseSystems.push(c); } },
  drawFrame(v, b, a) { const o = this.renderer; const q = this.gl; const p = q.viewportWidth; const c = q.viewportHeight; let m = this.percentfinished; m += v / a; if (m > 1) { m = 1; this.isCompleted = true; } this.percentfinished = m; q.blendFunc(q.ONE, q.ONE_MINUS_SRC_ALPHA); for (let r = 0, e = this.textures.length; r < e; r++) { const k = this.textures[r]; const s = k.initialState; const h = k.animations; if (k.hasHighlightedBulletAnimation) { if (!s.hidden) { var d; if (h.length > 0 && h[0].property === 'opacity') { const f = h[0].from.scalar; const g = h[0].to.scalar; const j = g - f; d = f + j * m; } else { d = k.initialState.opacity; } this.drawableObjects[r].Opacity = this.parentOpacity * d; this.drawableObjects[r].drawFrame(); } } else if (k.animations.length > 0) { const n = k.width; const l = k.height; const u = k.offset.pointX; const t = k.offset.pointY; const w = this.diffuseSystems[r]; const x = WebGraphics.translateMatrix4(o.slideProjectionMatrix, u, c - (t + l), 0); w.setMVPMatrix(x); w.drawFrame(this.percentfinished, 1); } else if (!k.initialState.hidden) { this.drawableObjects[r].Opacity = this.parentOpacity * k.initialState.opacity; this.drawableObjects[r].drawFrame(); } } },
}); var KNWebGLBuildFireworks = Class.create(KNWebGLProgram, {
  initialize($super, g, b) {
    this.programData = {
      name: 'com.apple.iWork.Keynote.KNFireworks', programNames: ['fireworks'], effect: b.effect, textures: b.textures,
    }; $super(g, this.programData); const d = this.gl; this.animParameterGroup = new KNAnimParameterGroup('Fireworks'); this.fireworksTexture = KNWebGLUtil.bindTextureWithImage(d, fireworksImage); this.fireworksCenterBurstTexture = KNWebGLUtil.bindTextureWithImage(d, fireworksCenterBurstImage); this.percentfinished = 0; this.prevpercentfinished = 0; this.drawableObjects = []; this.frameRect = this.frameOfEffectWithFrame(); this.slideSize = { width: d.viewportWidth, height: d.viewportHeight }; const j = this.effect; for (let c = 0, a = this.textures.length; c < a; c++) { const h = b.textures[c]; const f = { effect: j, textures: [h] }; const e = new KNWebGLDrawable(g, f); this.drawableObjects.push(e); } this.parentOpacity = j.baseLayer.initialState.opacity; this.animationWillBeginWithContext();
  },
  frameOfEffectWithFrame() { const b = this.gl; const a = { origin: { x: 0, y: 0 }, size: { width: b.viewportWidth, height: b.viewportHeight } }; return a; },
  p_orthoTransformWithScale(f, e, d) { const c = { width: d.size.width * f, height: d.size.height * f }; const b = WebGraphics.makeOrthoMatrix4(0, c.width, 0, c.height, -1, 1); const a = WebGraphics.translateMatrix4(b, e.x, -e.y, 0); return a; },
  p_setupFBOWithSize(a) { this.framebuffer = new TSDGLFrameBuffer(this.gl, a, 2); },
  p_fireworksSystemsForTR(h) { const k = this.renderer; const o = this.gl; const l = o.viewportWidth; const b = o.viewportHeight; const a = this.duration / 1000; const s = this.animParameterGroup; let g = a * s.doubleForKey('FireworksCount'); g = Math.max(2, g); const c = []; const t = 0; const q = 1; const m = parseInt(WebGraphics.randomBetween(0, g - 1)); for (let p = 0; p < g; p++) { const r = s.doubleForKey('ParticleCount'); const e = Math.min(l, b); const n = e * WebGraphics.doubleBetween(s.doubleForKey('FireworkSizeMin'), s.doubleForKey('FireworkSizeMax')); const d = new KNWebGLBuildFireworksSystem(k, this.program.fireworks, { width: h.width, height: h.height }, { width: l, height: b }, this.duration, { width: r, height: 1 }, { width: 1, height: 1 }, this.fireworksTexture); const f = WebGraphics.makeSize(s.doubleForKey('ParticleSizeMin'), s.doubleForKey('ParticleSizeMax')); f.width = f.width * e / 100; f.height = f.height * e / 100; d.randomParticleSizeMinMax = f; d.maxDistance = n; d.colorRandomness = s.doubleForKey('ParticleColorRandomness'); d.lifeSpanMinDuration = s.doubleForKey('ParticleLifeSpanMinDuration'); d.randomParticleSpeedMinMax = WebGraphics.makePoint(s.doubleForKey('FireworkSpeedMin'), s.doubleForKey('FireworkSpeedMax')); if (p % 2 === 0) { d.fireworkStartingPositionX = WebGraphics.randomBetween(0, 0.5); } else if (p % 2 === 1) { d.fireworkStartingPositionX = WebGraphics.randomBetween(0.5, 1); } if (p === t) { d.fireworkStartingPositionX = 0; } if (p === q) { d.fireworkStartingPositionX = 1; } let u = WebGraphics.randomBetween(s.doubleForKey('FireworkDurationMin'), s.doubleForKey('FireworkDurationMax')); u /= a; let j = WebGraphics.randomBetween(0, 1 - u); if (p === m) { j = 0; }j = Math.max(j, 0.001); d.lifeSpan = { start: j, duration: u }; d.setupWithTexture(h); c.push(d); } return c; },
  animationWillBeginWithContext() {
    const p = this.renderer; const t = this.gl; const w = this.animParameterGroup; const z = CGRectMake(0, 0, 512, 512); const B = CGRectMake(0, 0, this.slideSize.width, this.slideSize.height); const s = CGRectMake(0, 0, 1, 1); const m = CGSizeMake(2, 2); const x = this.frameRect; this.fireworksSystems = []; for (let u = 0, d = this.textures.length; u < d; u++) {
      const n = this.textures[u]; const q = { x: n.offset.pointX - x.origin.x, y: n.offset.pointY + n.height - (x.origin.y + x.size.height) }; const l = WebGraphics.makeOrthoMatrix4(0, x.size.width, 0, x.size.height, -1, 1); const k = WebGraphics.translateMatrix4(l, q.x, -q.y, 0); const g = new TSDGLShader(t); g.initWithDefaultTextureAndOpacityShader(); g.setMat4WithTransform3D(k, kTSDGLShaderUniformMVPMatrix); g.setGLint(0, kTSDGLShaderUniformTexture); const o = n.textureRect; const j = CGRectMake(0, 0, o.size.width, o.size.height); const h = new TSDGLDataBuffer(t); h.initWithVertexRect(j, TSDRectUnit, m, false, false); let a = p.slideProjectionMatrix; a = WebGraphics.translateMatrix4(a, q.x, -q.y, 0); const A = this.p_fireworksSystemsForTR(n); this.p_setupFBOWithSize(x.size); const f = this.fboShader = new TSDGLShader(t); f.initWithShaderFileNames('fireworkstrails', 'fireworkstrails'); f.setMat4WithTransform3D(l, kTSDGLShaderUniformMVPMatrix); f.setGLint(0, kTSDGLShaderUniformTexture); const b = this.fboDataBuffer = new TSDGLDataBuffer(t); b.initWithVertexRect(CGRectMake(0, 0, x.size.width, x.size.height), TSDRectUnit, m, false, false); const c = this.centerBurstShader = new TSDGLShader(t); c.initWithDefaultTextureAndOpacityShader(); c.setGLFloat(1, kTSDGLShaderUniformOpacity); const e = this.centerBurstDataBuffer = new TSDGLDataBuffer(t); e.initWithVertexRect(z, TSDRectUnit, m, false, false); const r = this._bloomEffect = new TSDGLBloomEffect(t); r.initWithEffectSize(x.size, w.doubleForKey('BloomBlurScale')); const v = {
        _baseOrthoTransform: l, _baseTransform: k, objectShader: g, objectDataBuffer: h, fireworksMVP: a, systems: A,
      }; this.fireworksSystems.push(v); t.clearColor(0, 0, 0, 0); t.enable(t.BLEND); t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA); t.disable(t.DEPTH_TEST);
    }
  },
  drawFrame(a, j, z) { const C = this.renderer; const p = this.gl; const c = this.program.fireworks; const q = c.uniforms; const h = this.buildOut; let m = this.percentfinished; const w = this.animParameterGroup; const F = w.doubleForKey('ParticleTrailsDitherAmount'); const n = w.doubleForKey('ParticleTrailsDitherMax'); const f = w.doubleForKey('BloomPower'); m += a / z; if (m >= 1) { m = 1; this.isCompleted = true; } this.percentfinished = m; p.blendFunc(p.ONE, p.ONE_MINUS_SRC_ALPHA); for (let R = 0, s = this.textures.length; R < s; R++) { const g = this.textures[R]; const M = g.initialState; const V = g.animations; if (g.hasHighlightedBulletAnimation) { if (!M.hidden) { var S; if (V.length > 0 && V[0].property === 'opacity') { const W = V[0].from.scalar; const D = V[0].to.scalar; const A = D - W; S = W + A * this.percentfinished; } else { S = g.initialState.opacity; } this.drawableObjects[R].Opacity = this.parentOpacity * S; this.drawableObjects[R].drawFrame(); } } else if (g.animations.length > 0) { if (this.isCompleted) { if (!h) { this.drawableObjects[R].Opacity = this.parentOpacity * g.initialState.opacity; this.drawableObjects[R].drawFrame(); } continue; } const b = g.width; const e = g.height; const J = g.offset.pointX; const H = g.offset.pointY; const u = p.viewportWidth; const r = p.viewportHeight; z /= 1000; const d = m; const K = TSDGLFrameBuffer.currentGLFramebuffer(p); const U = this.fireworksSystems[R]; const l = U.objectShader; const t = U.objectDataBuffer; this.p_drawObject(d, g, l, t); const N = this.framebuffer; const O = this.fboShader; const x = this.fboDataBuffer; const T = N.currentGLTexture(); N.setCurrentTextureToNext(); N.bindFramebuffer(); p.clear(p.COLOR_BUFFER_BIT); p.viewport(0, 0, N.size.width, N.size.height); p.bindTexture(p.TEXTURE_2D, T); let o = w.doubleForKey('FireworkDurationMin') / z; o = Math.min(o / 2, 1); const I = WebGraphics.clamp((m - o) / (1 - o), 0, 1); const B = 1 - WebGraphics.mix(w.doubleForKey('TrailsFadeOutMin'), w.doubleForKey('TrailsFadeOutMax'), Math.pow(I, 2)); O.setGLFloat(B, kTSDGLShaderUniformOpacity); O.setGLFloat(F, kShaderUniformNoiseAmount); O.setGLFloat(n, kShaderUniformNoiseMax); const Q = WebGraphics.makePoint(WebGraphics.randomBetween(0, 1), WebGraphics.randomBetween(0, 1)); O.setPoint2D(Q, kShaderUniformNoiseSeed); x.drawWithShader(this.fboShader, true); p.blendFunc(p.ONE, p.ONE_MINUS_SRC_ALPHA); p.useProgram(c.shaderProgram); let G = w.doubleForKey('Gravity'); G *= Math.min(u, r) * 0.001; G *= z; p.uniform1f(q.Gravity, G); const E = Math.min(u, r); const v = E * w.doubleForKey('ParticleSizeStart') / 100; p.uniform1f(q.StartScale, v); p.uniform1f(q.SparklePeriod, w.doubleForKey('SparklePeriod')); this.drawParticleSystemsWithPercent(m, false, 1, U); p.viewport(0, 0, p.viewportWidth, p.viewportHeight); N.unbindFramebufferAndBindGLFramebuffer(K); let P = w.doubleForKey('FireworkDurationMax'); P = Math.min(P, 0.999); const L = WebGraphics.clamp((m - P) / (1 - P), 0, 1); const k = 1 - w.doubleForAnimationCurve('ParticleTransparency', L); this._bloomEffect.bindFramebuffer(); p.clear(p.COLOR_BUFFER_BIT); O.setGLFloat(k, kTSDGLShaderUniformOpacity); O.setGLFloat(0, kShaderUniformNoiseAmount); p.blendFunc(p.SRC_ALPHA, p.ONE_MINUS_SRC_ALPHA); p.bindTexture(p.TEXTURE_2D, N.currentGLTexture()); x.drawWithShader(O, true); p.blendFunc(p.ONE, p.ONE_MINUS_SRC_ALPHA); p.useProgram(c.shaderProgram); this.drawParticleSystemsWithPercent(m, true, k, U); this._bloomEffect.unbindFramebufferAndBindGLFramebuffer(K); p.blendFunc(p.ONE, p.ONE); this._bloomEffect.drawBloomEffectWithMVPMatrix(U._baseOrthoTransform, f, K); p.blendFunc(p.ONE, p.ONE_MINUS_SRC_ALPHA); } else if (!g.initialState.hidden) { this.drawableObjects[R].Opacity = this.parentOpacity * g.initialState.opacity; this.drawableObjects[R].drawFrame(); } } this.prevpercentfinished = this.percentfinished; },
  p_drawObject(h, c, i, a) { const e = this.gl; const b = this.animParameterGroup; const d = b.doubleForKey('TextOpacityBeginTime'); const f = b.doubleForKey('TextOpacityEndTime'); h = WebGraphics.clamp((h - d) / (f - d), 0, 1); let g = this.parentOpacity * c.initialState.opacity; g *= b.doubleForAnimationCurve('TextOpacityTiming', h); i.setGLFloat(g, kTSDGLShaderUniformOpacity); e.blendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA); e.bindTexture(e.TEXTURE_2D, c.texture); a.drawWithShader(i, true); },
  drawParticleSystemsWithPercent(a, v, l, u) { const p = this.renderer; const q = this.gl; const h = this.program.fireworks; const w = h.uniforms; const z = this.animParameterGroup; const e = u.systems; const n = u._baseTransform; const B = u.fireworksMVP; q.useProgram(h.shaderProgram); q.uniform1f(w.ShouldSparkle, v ? 1 : 0); for (let r = 0, d = e.length; r < d; r++) { const g = e[r]; const j = g.lifeSpan; var f = (a - j.start) / j.duration; if (f <= 0 || f >= 1) { continue; } var f = WebGraphics.clamp(f, 0, 1); let c = (this.prevpercentfinished - j.start) / j.duration; c = WebGraphics.clamp(c, f / 2, 1); let b = l; if (v) { b = 1 - z.doubleForAnimationCurve('ParticleTransparency', f); } const s = z.doubleForAnimationCurve('ParticleBurstTiming', c); const k = z.doubleForAnimationCurve('ParticleBurstTiming', f); q.uniform1f(w.ParticleBurstTiming, k); q.uniform1f(w.PreviousParticleBurstTiming, s); q.uniform1f(w.PreviousPercent, c); if (!v) { if (!g.didDrawCenterBurst) { q.bindTexture(q.TEXTURE_2D, this.fireworksCenterBurstTexture); let A = q.viewportHeight / 512; A *= WebGraphics.randomBetween(z.doubleForKey('CenterBurstScaleMin'), z.doubleForKey('CenterBurstScaleMax')); const x = g._startingPoint; let m = WebGraphics.translateMatrix4(n, x.x, x.y, 0); const o = WebGraphics.makePoint(-(512 / 2 * A), -(512 / 2 * A)); m = WebGraphics.translateMatrix4(m, o.x, o.y, 0); m = WebGraphics.scaleMatrix4(m, A, A, 1); this.centerBurstShader.setGLFloat(z.doubleForKey('CenterBurstOpacity'), kTSDGLShaderUniformOpacity); this.centerBurstShader.setMat4WithTransform3D(m, kTSDGLShaderUniformMVPMatrix); q.blendFunc(q.SRC_ALPHA, q.ONE_MINUS_SRC_ALPHA); this.centerBurstDataBuffer.drawWithShader(this.centerBurstShader, true); q.blendFunc(q.ONE, q.ONE_MINUS_SRC_ALPHA); g.didDrawCenterBurst = true; } }q.useProgram(h.shaderProgram); g.setMVPMatrix(B); g.drawFrame(f, b); } },
});
